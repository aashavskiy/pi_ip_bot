{
    "": {
        "directories": [
            ".pytest_cache",
            "tests",
            "scripts",
            "commands",
            ".git",
            ".vscode"
        ],
        "files": {
            "collect_structure_and_files.py": "import os\nimport json\nfrom gitignore_parser import parse_gitignore\n\ndef collect_directory_structure_and_files(base_path='.'):\n    file_structure = {}\n    \n    # Parse .gitignore file if it exists\n    gitignore_file = os.path.join(base_path, '.gitignore')\n    if os.path.exists(gitignore_file):\n        is_ignored = parse_gitignore(gitignore_file)\n    else:\n        is_ignored = lambda path: False  # No gitignore file, don't ignore anything\n\n    # Walk through all directories and files starting from base_path\n    for root, dirs, files in os.walk(base_path):\n        # Skip files that match .gitignore\n        dirs[:] = [d for d in dirs if not is_ignored(os.path.join(root, d))]\n        files = [f for f in files if not is_ignored(os.path.join(root, f))]\n        \n        # Get the relative path\n        relative_root = os.path.relpath(root, base_path)\n        \n        if relative_root == '.':\n            relative_root = ''\n        \n        # Store the directory and file structure\n        file_structure[relative_root] = {\n            'directories': dirs,\n            'files': {}\n        }\n        \n        for file in files:\n            file_path = os.path.join(root, file)\n            \n            # Skip non-code files or files that can't be read\n            if file.endswith(('.py', '.txt', '.md', '.json', '.yml', '.yaml')):  # Add more extensions as needed\n                try:\n                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                        file_structure[relative_root]['files'][file] = f.read()\n                except Exception as e:\n                    print(f\"Could not read {file_path}: {e}\")\n    \n    return file_structure\n\ndef save_directory_structure_and_files(file_structure, output_filename=\"directory_structure_with_files.json\"):\n    # Save the directory structure and file contents to a JSON file\n    with open(output_filename, 'w', encoding='utf-8') as f:\n        json.dump(file_structure, f, ensure_ascii=False, indent=4)\n    print(f\"Directory structure and file contents saved to {output_filename}\")\n\nif __name__ == \"__main__\":\n    base_path = '.'  # Current directory\n    structure_with_files = collect_directory_structure_and_files(base_path)\n    save_directory_structure_and_files(structure_with_files)",
            "requirements.txt": "python-telegram-bot\nrequests\npython-dotenv",
            "device_list.txt": "",
            "logger.py": "import os\nfrom datetime import datetime\nfrom bot_utils import load_whitelist\n\nBOT_WHITELIST_FILE = \"bot_whitelist.txt\"\n\n# Log user requests\nasync def log_request(user_id, username, command):  # ‚úÖ Ensure it expects three arguments\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    log_entry = f\"[{timestamp}] {username} ({user_id}) used: {command}\\n\"\n\n    with open(\"bot_requests.log\", \"a\") as log_file:\n        log_file.write(log_entry)\n\n    # Check if the user is in the whitelist\n    bot_whitelist = load_whitelist(BOT_WHITELIST_FILE)\n    if str(user_id) not in bot_whitelist:\n        print(f\"üö® Unauthorized access attempt: {username} ({user_id}) tried {command}\")",
            "README.md": "# pi_ip_bot\n\n\ntest\n",
            "piipbot.py": "# /Users/alexanderashavskiy/projects/pi_ip_bot/piipbot.py\n\nimport os\nimport importlib\nimport logging\nfrom dotenv import load_dotenv\nfrom telegram import Update, ReplyKeyboardRemove\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandler\nfrom commands.admin import handle_approval, handle_approval_callback\nfrom commands.start import start_command\nfrom commands.menu import menu_command, handle_menu_buttons, get_main_menu\n\n# Load environment variables\nload_dotenv()\nBOT_TOKEN = os.getenv(\"BOT_TOKEN\")\nADMIN_ID = os.getenv(\"ADMIN_ID\")\n\nif not ADMIN_ID:\n    raise ValueError(\"ADMIN_ID is not set in the environment variables.\")\n\n# Function to dynamically load command handlers from the \"commands\" folder\ndef load_commands():\n    commands = {}\n    commands_dir = \"commands\"\n\n    for filename in os.listdir(commands_dir):\n        if filename.endswith(\".py\") and filename != \"__init__.py\":\n            module_name = f\"{commands_dir}.{filename[:-3]}\"  # Remove .py extension\n            module = importlib.import_module(module_name)\n\n            if hasattr(module, f\"{filename[:-3]}_command\"):\n                commands[filename[:-3]] = getattr(module, f\"{filename[:-3]}_command\")\n\n    return commands\n\n# Main function to start the bot\ndef main():\n    app = Application.builder().token(BOT_TOKEN).build()\n\n    # Dynamically load all command handlers\n    commands = load_commands()\n    for cmd_name, cmd_func in commands.items():\n        app.add_handler(CommandHandler(cmd_name, cmd_func))\n        print(f\"‚úÖ Loaded command: /{cmd_name}\")\n\n    # Add start command and button handler\n    app.add_handler(CommandHandler(\"start\", start_command))\n    app.add_handler(CallbackQueryHandler(handle_menu_buttons, pattern='^(?!approve|deny).*$'))\n    app.add_handler(CallbackQueryHandler(handle_approval_callback, pattern='^(approve|deny):'))\n\n    # Register approval handler\n    app.add_handler(MessageHandler(filters.ALL, handle_approval))\n\n    print(\"ü§ñ Bot is running...\")\n    app.run_polling()\n\nasync def start(update: Update, context):\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    logging.info(f\"Checking authorization for user ID: {user_id}, Username: {username}\")\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"üö´ You are not authorized to use this bot. An approval request has been sent to the admin.\")\n        return\n\n    await update.message.reply_text(\n        \"üëã Welcome to Pi IP Bot! Use the menu to select a command.\",\n        reply_markup=ReplyKeyboardRemove()\n    )\n    await update.message.reply_text(\n        \"üìç Main Menu:\",\n        reply_markup=get_main_menu()\n    )\n\nif __name__ == \"__main__\":\n    main()",
            "bot_utils.py": "import os\nimport logging\nfrom telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup\n\nADMIN_ID = os.getenv(\"ADMIN_ID\")\n\ndef load_whitelist(filename):\n    if not os.path.exists(filename):\n        return set()\n    with open(filename, \"r\") as f:\n        return set(line.strip().split()[0] for line in f if line.strip())\n\ndef add_to_whitelist(filename, user_id, username=None):\n    with open(filename, \"a\") as f:\n        if username:\n            f.write(f\"{user_id}  # {username}\\n\")\n        else:\n            f.write(f\"{user_id}\\n\")\n\ndef is_user_in_whitelist(filename, user_id):\n    whitelist = load_whitelist(filename)\n    return str(user_id) in whitelist\n\ndef check_whitelist(user_id):\n    return is_user_in_whitelist(BOT_WHITELIST_FILE, user_id)\n\nBOT_WHITELIST_FILE = \"bot_whitelist.txt\"\nVPN_WHITELIST_FILE = \"vpn_whitelist.txt\"\n\nVPN_WHITELIST = load_whitelist(VPN_WHITELIST_FILE)\n\ndef is_user_in_bot_whitelist(user_id):\n    return is_user_in_whitelist(BOT_WHITELIST_FILE, user_id)\n\ndef is_user_in_vpn_whitelist(user_id):\n    return is_user_in_whitelist(VPN_WHITELIST_FILE, user_id)\n\ndef add_user_to_bot_whitelist(user_id, username=None):\n    add_to_whitelist(BOT_WHITELIST_FILE, user_id, username)\n\ndef add_to_vpn_whitelist(user_id, username=None):\n    add_to_whitelist(VPN_WHITELIST_FILE, user_id, username)\n\ndef is_user_authorized(user_id):\n    authorized_users = load_whitelist(BOT_WHITELIST_FILE)\n    logging.info(f\"Authorized users: {authorized_users}\")\n    return user_id in authorized_users\n\nasync def request_approval(user_id, username, approval_type):\n    bot = Bot(token=os.getenv(\"BOT_TOKEN\"))\n    admin_id = os.getenv(\"ADMIN_ID\")\n    if not admin_id:\n        raise ValueError(\"ADMIN_ID is not set in the environment variables.\")\n    message = f\"üö® Approval request for {approval_type} access:\\nUser ID: {user_id}\\nUsername: @{username}\"\n    keyboard = [\n        [\n            InlineKeyboardButton(\"Approve\", callback_data=f\"approve:{user_id}:{username}:{approval_type}\"),\n            InlineKeyboardButton(\"Deny\", callback_data=f\"deny:{user_id}:{username}:{approval_type}\")\n        ]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    await bot.send_message(chat_id=admin_id, text=message, reply_markup=reply_markup)\n"
        }
    },
    ".pytest_cache": {
        "directories": [
            "v"
        ],
        "files": {
            "README.md": "# pytest cache directory #\n\nThis directory contains data from the pytest's cache plugin,\nwhich provides the `--lf` and `--ff` options, as well as the `cache` fixture.\n\n**Do not** commit this to version control.\n\nSee [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.\n"
        }
    },
    ".pytest_cache/v": {
        "directories": [
            "cache"
        ],
        "files": {}
    },
    ".pytest_cache/v/cache": {
        "directories": [],
        "files": {}
    },
    "tests": {
        "directories": [],
        "files": {
            "test_bot.py": "import pytest\nimport asyncio\nimport sys\nimport os\nfrom telegram import Update, User, Message, Chat, CallbackQuery\nfrom telegram.ext import CallbackContext\n\n# –î–æ–±–∞–≤–ª—è–µ–º –∫–æ—Ä–Ω–µ–≤—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞ –≤ sys.path\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nfrom bot_utils import is_user_authorized, request_approval, add_to_whitelist, BOT_WHITELIST_FILE, VPN_WHITELIST_FILE\nfrom commands.menu import menu_command, vpn_menu\nfrom commands.admin import handle_approval_callback\n\n@pytest.fixture\ndef mock_update():\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    return Update(update_id=1, message=message)\n\n@pytest.fixture\ndef mock_context(mock_update):\n    return CallbackContext.from_update(mock_update, None)\n\n@pytest.fixture\ndef mock_callback_query():\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    return CallbackQuery(id=1, from_user=user, message=message, chat_instance=\"instance\", data=\"\")\n\n@pytest.mark.asyncio\nasync def test_menu_command_authorized(mock_update, mock_context, monkeypatch):\n    def mock_is_user_authorized(user_id):\n        return True\n\n    monkeypatch.setattr('bot_utils.is_user_authorized', mock_is_user_authorized)\n    await menu_command(mock_update, mock_context)\n    assert mock_update.message.reply_text.call_count == 2\n\n@pytest.mark.asyncio\nasync def test_menu_command_unauthorized(mock_update, mock_context, monkeypatch):\n    def mock_is_user_authorized(user_id):\n        return False\n\n    async def mock_request_approval(user_id, username, approval_type):\n        pass\n\n    monkeypatch.setattr('bot_utils.is_user_authorized', mock_is_user_authorized)\n    monkeypatch.setattr('bot_utils.request_approval', mock_request_approval)\n    await menu_command(mock_update, mock_context)\n    assert mock_update.message.reply_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_vpn_menu_authorized(mock_update, mock_context, monkeypatch):\n    def mock_is_user_in_vpn_whitelist(user_id):\n        return True\n\n    monkeypatch.setattr('bot_utils.is_user_in_vpn_whitelist', mock_is_user_in_vpn_whitelist)\n    await vpn_menu(mock_update, mock_context)\n    assert mock_update.message.reply_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_vpn_menu_unauthorized(mock_update, mock_context, monkeypatch):\n    def mock_is_user_in_vpn_whitelist(user_id):\n        return False\n\n    async def mock_request_approval(user_id, username, approval_type):\n        pass\n\n    monkeypatch.setattr('bot_utils.is_user_in_vpn_whitelist', mock_is_user_in_vpn_whitelist)\n    monkeypatch.setattr('bot_utils.request_approval', mock_request_approval)\n    await vpn_menu(mock_update, mock_context)\n    assert mock_update.message.reply_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_handle_approval_callback_approve_bot(mock_context, monkeypatch):\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    callback_query = CallbackQuery(id=1, from_user=user, message=message, chat_instance=\"instance\", data=\"approve:12345:TestUser:bot\")\n    update = Update(update_id=1, callback_query=callback_query)\n\n    def mock_add_to_whitelist(filename, user_id, username):\n        assert filename == BOT_WHITELIST_FILE\n        assert user_id == \"12345\"\n        assert username == \"TestUser\"\n\n    monkeypatch.setattr('bot_utils.add_to_whitelist', mock_add_to_whitelist)\n    await handle_approval_callback(update, mock_context)\n    assert update.callback_query.edit_message_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_handle_approval_callback_approve_vpn(mock_context, monkeypatch):\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    callback_query = CallbackQuery(id=1, from_user=user, message=message, chat_instance=\"instance\", data=\"approve:12345:TestUser:vpn\")\n    update = Update(update_id=1, callback_query=callback_query)\n\n    def mock_add_to_whitelist(filename, user_id, username):\n        assert filename == VPN_WHITELIST_FILE\n        assert user_id == \"12345\"\n        assert username == \"TestUser\"\n\n    monkeypatch.setattr('bot_utils.add_to_whitelist', mock_add_to_whitelist)\n    await handle_approval_callback(update, mock_context)\n    assert update.callback_query.edit_message_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_handle_approval_callback_deny(mock_context):\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    callback_query = CallbackQuery(id=1, from_user=user, message=message, chat_instance=\"instance\", data=\"deny:12345:TestUser:bot\")\n    update = Update(update_id=1, callback_query=callback_query)\n\n    await handle_approval_callback(update, mock_context)\n    assert update.callback_query.edit_message_text.call_count == 1\n",
            "import pytest.py": "import pytest\nfrom unittest.mock import patch, MagicMock\nfrom piipbot import main, load_commands\n\n@pytest.fixture\ndef mock_env(monkeypatch):\n    monkeypatch.setenv(\"BOT_TOKEN\", \"test_token\")\n    monkeypatch.setenv(\"ADMIN_ID\", \"admin_id\")\n\n@pytest.fixture\ndef mock_application_builder():\n    with patch('piipbot.Application.builder') as mock_builder:\n        mock_app = MagicMock()\n        mock_builder.return_value.token.return_value.build.return_value = mock_app\n        yield mock_app\n\n@pytest.fixture\ndef mock_load_commands():\n    with patch('piipbot.load_commands') as mock_load:\n        mock_load.return_value = {\n            \"test_command\": MagicMock()\n        }\n        yield mock_load\n\ndef test_main(mock_env, mock_application_builder, mock_load_commands):\n    main()\n\n    # Check if the bot token is set correctly\n    mock_application_builder.builder().token.assert_called_with(\"test_token\")\n\n    # Check if the command handlers are added correctly\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n\n    # Check if the bot is running\n    mock_application_builder.run_polling.assert_called_once()"
        }
    },
    "scripts": {
        "directories": [],
        "files": {}
    },
    "commands": {
        "directories": [],
        "files": {
            "start.py": "from telegram import Update, ReplyKeyboardRemove\nfrom telegram.ext import CallbackContext\nfrom commands.menu import get_main_menu\nfrom logger import log_request\n\nasync def start_command(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    await log_request(user_id, username, \"/start\")\n\n    await update.message.reply_text(\n        \"üëã Welcome to Pi IP Bot! Use the menu to select a command.\",\n        reply_markup=ReplyKeyboardRemove()\n    )\n    await update.message.reply_text(\n        \"üìç Main Menu:\",\n        reply_markup=get_main_menu()\n    )",
            "menu.py": "# /Users/alexanderashavskiy/projects/pi_ip_bot/commands/menu.py\n\nfrom telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove\nfrom telegram.ext import CallbackContext\nfrom commands.ip import ip_command  # Import the ip_command function\nfrom commands.uptime import uptime_command  # Import uptime command function\n\n# This function handles buttons pressed in the menu\nasync def handle_menu_buttons(update: Update, context: CallbackContext) -> None:\n    if update.message:\n        text = update.message.text.strip()\n        message = update.message\n    elif update.callback_query:\n        text = update.callback_query.data\n        message = update.callback_query.message\n    else:\n        return\n\n    context.args = text.split()\n\n    # Check if the button pressed is \"IP\"\n    if text == \"üåê IP\":\n        await ip_command(update, context)  # This will trigger the ip_command when IP button is pressed\n    elif text == \"‚è≥ Uptime\":\n        await uptime_command(update, context)\n    else:\n        await message.reply_text(\"‚ùå Unknown command. Please use the menu or type /help for available commands.\")\n\ndef get_main_menu():\n    return ReplyKeyboardMarkup([\n        [\"üåê IP\", \"‚è≥ Uptime\"]\n    ], resize_keyboard=True, one_time_keyboard=True)\n\nasync def menu_command(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"üö´ You are not authorized to use this bot. An approval request has been sent to the admin.\")\n        return\n\n    await update.message.reply_text(\n        \"üìç Main Menu:\",\n        reply_markup=get_main_menu()  # Send the main menu only once\n    )",
            "admin.py": "import logging\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import CallbackContext\nfrom bot_utils import add_to_whitelist, is_user_authorized, request_approval, BOT_WHITELIST_FILE, VPN_WHITELIST_FILE\n\nasync def handle_approval(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"üö´ You are not authorized to use this bot. An approval request has been sent to the admin.\")\n    else:\n        await update.message.reply_text(\"‚úÖ You are authorized to use this bot.\")\n        add_to_whitelist(BOT_WHITELIST_FILE, user_id, username)\n\nasync def handle_approval_callback(update: Update, context: CallbackContext) -> None:\n    query = update.callback_query\n    await query.answer()\n    data = query.data.split(':')\n    action = data[0]\n    user_id = data[1]\n    username = data[2]\n    approval_type = data[3]\n\n    logging.info(f\"Approval action: {action}, User ID: {user_id}, Username: {username}, Type: {approval_type}\")\n\n    if action == 'approve':\n        if approval_type == 'bot':\n            add_to_whitelist(BOT_WHITELIST_FILE, user_id, username)\n        elif approval_type == 'vpn':\n            add_to_whitelist(VPN_WHITELIST_FILE, user_id, username)\n        await query.edit_message_text(f\"‚úÖ User @{username} (ID: {user_id}) has been approved for {approval_type} access.\")\n    elif action == 'deny':\n        await query.edit_message_text(f\"‚ùå User @{username} (ID: {user_id}) has been denied for {approval_type} access.\")",
            "ip.py": "# /Users/alexanderashavskiy/projects/pi_ip_bot/commands/ip.py\n\nimport subprocess\nfrom telegram import Update\nfrom telegram.ext import CallbackContext\n\n# Function to handle the IP command\nasync def ip_command(update: Update, context: CallbackContext) -> None:\n    try:\n        # Get external IP using `curl` (or another way to get public IP)\n        ip_address = subprocess.check_output([\"curl\", \"-s\", \"https://api.ipify.org\"]).decode(\"utf-8\")\n        await update.message.reply_text(f\"Your IP address is: {ip_address}\")\n    except subprocess.CalledProcessError as e:\n        await update.message.reply_text(\"‚ùå Unable to fetch the IP address.\")",
            "uptime.py": "import subprocess\nfrom telegram import Update\nfrom telegram.ext import CallbackContext\nfrom bot_utils import is_user_authorized, request_approval\nfrom logger import log_request\n\nasync def uptime_command(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"üö´ You are not authorized to use this bot. An approval request has been sent to the admin.\")\n        return\n\n    await log_request(user_id, username, \"/uptime\")\n\n    try:\n        # Get system uptime\n        uptime_output = subprocess.check_output(\"uptime -p\", shell=True).decode().strip()\n        await update.message.reply_text(f\"‚è≥ Server Uptime: `{uptime_output}`\", parse_mode=\"Markdown\")\n\n    except subprocess.CalledProcessError as e:\n        await update.message.reply_text(\"‚ùå Error: Unable to fetch system uptime.\")\n        print(f\"ERROR: Failed to fetch uptime - {e}\")  # Log the error"
        }
    },
    ".git": {
        "directories": [
            "objects",
            "info",
            "logs",
            "hooks",
            "refs"
        ],
        "files": {}
    },
    ".git/objects": {
        "directories": [
            "61",
            "0d",
            "95",
            "59",
            "92",
            "0c",
            "66",
            "3e",
            "50",
            "68",
            "57",
            "3b",
            "6f",
            "03",
            "9b",
            "9e",
            "04",
            "6a",
            "32",
            "35",
            "69",
            "3c",
            "56",
            "51",
            "3d",
            "58",
            "67",
            "0b",
            "93",
            "94",
            "0e",
            "60",
            "34",
            "5a",
            "5f",
            "33",
            "05",
            "9d",
            "9c",
            "02",
            "a4",
            "a3",
            "b5",
            "b2",
            "d9",
            "ac",
            "ad",
            "bb",
            "d7",
            "d0",
            "be",
            "b3",
            "df",
            "da",
            "b4",
            "a2",
            "a5",
            "bd",
            "d1",
            "d6",
            "bc",
            "ae",
            "d8",
            "ab",
            "e5",
            "e2",
            "f4",
            "f3",
            "eb",
            "c7",
            "c0",
            "ee",
            "c9",
            "fc",
            "fd",
            "f2",
            "f5",
            "e3",
            "cf",
            "ca",
            "e4",
            "fe",
            "c8",
            "fb",
            "ed",
            "c1",
            "c6",
            "ec",
            "4e",
            "20",
            "18",
            "27",
            "4b",
            "pack",
            "7d",
            "29",
            "7c",
            "16",
            "42",
            "89",
            "45",
            "1f",
            "73",
            "87",
            "80",
            "74",
            "1a",
            "28",
            "17",
            "7b",
            "8f",
            "8a",
            "7e",
            "10",
            "19",
            "4c",
            "26",
            "21",
            "4d",
            "75",
            "81",
            "86",
            "72",
            "44",
            "2a",
            "2f",
            "43",
            "88",
            "9f",
            "6b",
            "07",
            "38",
            "00",
            "6e",
            "9a",
            "36",
            "5c",
            "09",
            "5d",
            "31",
            "info",
            "91",
            "65",
            "62",
            "96",
            "3a",
            "54",
            "98",
            "53",
            "3f",
            "30",
            "5e",
            "5b",
            "37",
            "08",
            "6d",
            "01",
            "06",
            "6c",
            "39",
            "99",
            "52",
            "55",
            "97",
            "63",
            "0f",
            "0a",
            "64",
            "90",
            "bf",
            "d3",
            "d4",
            "ba",
            "a0",
            "a7",
            "b8",
            "b1",
            "dd",
            "dc",
            "b6",
            "a9",
            "d5",
            "d2",
            "aa",
            "af",
            "b7",
            "db",
            "a8",
            "de",
            "b0",
            "a6",
            "b9",
            "a1",
            "ef",
            "c3",
            "c4",
            "ea",
            "e1",
            "cd",
            "cc",
            "e6",
            "f9",
            "f0",
            "f7",
            "e8",
            "fa",
            "ff",
            "c5",
            "c2",
            "f6",
            "e9",
            "f1",
            "e7",
            "cb",
            "f8",
            "ce",
            "e0",
            "46",
            "2c",
            "79",
            "2d",
            "41",
            "83",
            "1b",
            "77",
            "48",
            "70",
            "1e",
            "84",
            "4a",
            "24",
            "23",
            "4f",
            "15",
            "12",
            "8c",
            "85",
            "1d",
            "71",
            "76",
            "1c",
            "82",
            "49",
            "40",
            "2e",
            "2b",
            "47",
            "78",
            "8b",
            "13",
            "7f",
            "7a",
            "14",
            "8e",
            "22",
            "25"
        ],
        "files": {}
    },
    ".git/objects/61": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/95": {
        "directories": [],
        "files": {}
    },
    ".git/objects/59": {
        "directories": [],
        "files": {}
    },
    ".git/objects/92": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/66": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/50": {
        "directories": [],
        "files": {}
    },
    ".git/objects/68": {
        "directories": [],
        "files": {}
    },
    ".git/objects/57": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/03": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/04": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/32": {
        "directories": [],
        "files": {}
    },
    ".git/objects/35": {
        "directories": [],
        "files": {}
    },
    ".git/objects/69": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/56": {
        "directories": [],
        "files": {}
    },
    ".git/objects/51": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/58": {
        "directories": [],
        "files": {}
    },
    ".git/objects/67": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/93": {
        "directories": [],
        "files": {}
    },
    ".git/objects/94": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/60": {
        "directories": [],
        "files": {}
    },
    ".git/objects/34": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/33": {
        "directories": [],
        "files": {}
    },
    ".git/objects/05": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/02": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ac": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ad": {
        "directories": [],
        "files": {}
    },
    ".git/objects/bb": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/be": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/df": {
        "directories": [],
        "files": {}
    },
    ".git/objects/da": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/bd": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/bc": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ae": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ab": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/eb": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ee": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fc": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fd": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/cf": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ca": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fe": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fb": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ed": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ec": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/20": {
        "directories": [],
        "files": {}
    },
    ".git/objects/18": {
        "directories": [],
        "files": {}
    },
    ".git/objects/27": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/pack": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/29": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/16": {
        "directories": [],
        "files": {}
    },
    ".git/objects/42": {
        "directories": [],
        "files": {}
    },
    ".git/objects/89": {
        "directories": [],
        "files": {}
    },
    ".git/objects/45": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/73": {
        "directories": [],
        "files": {}
    },
    ".git/objects/87": {
        "directories": [],
        "files": {}
    },
    ".git/objects/80": {
        "directories": [],
        "files": {}
    },
    ".git/objects/74": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/28": {
        "directories": [],
        "files": {}
    },
    ".git/objects/17": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/10": {
        "directories": [],
        "files": {}
    },
    ".git/objects/19": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/26": {
        "directories": [],
        "files": {}
    },
    ".git/objects/21": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/75": {
        "directories": [],
        "files": {}
    },
    ".git/objects/81": {
        "directories": [],
        "files": {}
    },
    ".git/objects/86": {
        "directories": [],
        "files": {}
    },
    ".git/objects/72": {
        "directories": [],
        "files": {}
    },
    ".git/objects/44": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/43": {
        "directories": [],
        "files": {}
    },
    ".git/objects/88": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/07": {
        "directories": [],
        "files": {}
    },
    ".git/objects/38": {
        "directories": [],
        "files": {}
    },
    ".git/objects/00": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/36": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/09": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/31": {
        "directories": [],
        "files": {}
    },
    ".git/objects/info": {
        "directories": [],
        "files": {}
    },
    ".git/objects/91": {
        "directories": [],
        "files": {}
    },
    ".git/objects/65": {
        "directories": [],
        "files": {}
    },
    ".git/objects/62": {
        "directories": [],
        "files": {}
    },
    ".git/objects/96": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/54": {
        "directories": [],
        "files": {}
    },
    ".git/objects/98": {
        "directories": [],
        "files": {}
    },
    ".git/objects/53": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/30": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/37": {
        "directories": [],
        "files": {}
    },
    ".git/objects/08": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/01": {
        "directories": [],
        "files": {}
    },
    ".git/objects/06": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/39": {
        "directories": [],
        "files": {}
    },
    ".git/objects/99": {
        "directories": [],
        "files": {}
    },
    ".git/objects/52": {
        "directories": [],
        "files": {}
    },
    ".git/objects/55": {
        "directories": [],
        "files": {}
    },
    ".git/objects/97": {
        "directories": [],
        "files": {}
    },
    ".git/objects/63": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/64": {
        "directories": [],
        "files": {}
    },
    ".git/objects/90": {
        "directories": [],
        "files": {}
    },
    ".git/objects/bf": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ba": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/dd": {
        "directories": [],
        "files": {}
    },
    ".git/objects/dc": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/aa": {
        "directories": [],
        "files": {}
    },
    ".git/objects/af": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/db": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/de": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ef": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ea": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/cd": {
        "directories": [],
        "files": {}
    },
    ".git/objects/cc": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fa": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ff": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/cb": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ce": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/46": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/79": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/41": {
        "directories": [],
        "files": {}
    },
    ".git/objects/83": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/77": {
        "directories": [],
        "files": {}
    },
    ".git/objects/48": {
        "directories": [],
        "files": {}
    },
    ".git/objects/70": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/84": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/24": {
        "directories": [],
        "files": {}
    },
    ".git/objects/23": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/15": {
        "directories": [],
        "files": {}
    },
    ".git/objects/12": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/85": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/71": {
        "directories": [],
        "files": {}
    },
    ".git/objects/76": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/82": {
        "directories": [],
        "files": {}
    },
    ".git/objects/49": {
        "directories": [],
        "files": {}
    },
    ".git/objects/40": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/47": {
        "directories": [],
        "files": {}
    },
    ".git/objects/78": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/13": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/14": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/22": {
        "directories": [],
        "files": {}
    },
    ".git/objects/25": {
        "directories": [],
        "files": {}
    },
    ".git/info": {
        "directories": [],
        "files": {}
    },
    ".git/logs": {
        "directories": [
            "refs"
        ],
        "files": {}
    },
    ".git/logs/refs": {
        "directories": [
            "heads",
            "remotes"
        ],
        "files": {}
    },
    ".git/logs/refs/heads": {
        "directories": [],
        "files": {}
    },
    ".git/logs/refs/remotes": {
        "directories": [
            "origin"
        ],
        "files": {}
    },
    ".git/logs/refs/remotes/origin": {
        "directories": [],
        "files": {}
    },
    ".git/hooks": {
        "directories": [],
        "files": {}
    },
    ".git/refs": {
        "directories": [
            "heads",
            "tags",
            "remotes"
        ],
        "files": {}
    },
    ".git/refs/heads": {
        "directories": [],
        "files": {}
    },
    ".git/refs/tags": {
        "directories": [],
        "files": {}
    },
    ".git/refs/remotes": {
        "directories": [
            "origin"
        ],
        "files": {}
    },
    ".git/refs/remotes/origin": {
        "directories": [],
        "files": {}
    },
    ".vscode": {
        "directories": [],
        "files": {
            "settings.json": "{\n    \"github.copilot.enable\": {\n        \"python\": true\n    },\n    \"python.testing.unittestArgs\": [\n        \"-v\",\n        \"-s\",\n        \"./tests\",\n        \"-p\",\n        \"*test.py\"\n    ],\n    \"python.testing.pytestEnabled\": false,\n    \"python.testing.unittestEnabled\": true\n}"
        }
    }
}
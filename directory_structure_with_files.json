{
    "": {
        "directories": [
            ".pytest_cache",
            "tests",
            "scripts",
            "commands",
            ".git",
            ".vscode"
        ],
        "files": {
            "collect_structure_and_files.py": "import os\nimport json\nfrom gitignore_parser import parse_gitignore\n\ndef collect_directory_structure_and_files(base_path='.'):\n    file_structure = {}\n    \n    # Parse .gitignore file if it exists\n    gitignore_file = os.path.join(base_path, '.gitignore')\n    if os.path.exists(gitignore_file):\n        is_ignored = parse_gitignore(gitignore_file)\n    else:\n        is_ignored = lambda path: False  # No gitignore file, don't ignore anything\n\n    # Walk through all directories and files starting from base_path\n    for root, dirs, files in os.walk(base_path):\n        # Skip files that match .gitignore\n        dirs[:] = [d for d in dirs if not is_ignored(os.path.join(root, d))]\n        files = [f for f in files if not is_ignored(os.path.join(root, f))]\n        \n        # Get the relative path\n        relative_root = os.path.relpath(root, base_path)\n        \n        if relative_root == '.':\n            relative_root = ''\n        \n        # Store the directory and file structure\n        file_structure[relative_root] = {\n            'directories': dirs,\n            'files': {}\n        }\n        \n        for file in files:\n            file_path = os.path.join(root, file)\n            \n            # Skip non-code files or files that can't be read\n            if file.endswith(('.py', '.txt', '.md', '.json', '.yml', '.yaml')):  # Add more extensions as needed\n                try:\n                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                        file_structure[relative_root]['files'][file] = f.read()\n                except Exception as e:\n                    print(f\"Could not read {file_path}: {e}\")\n    \n    return file_structure\n\ndef save_directory_structure_and_files(file_structure, output_filename=\"directory_structure_with_files.json\"):\n    # Save the directory structure and file contents to a JSON file\n    with open(output_filename, 'w', encoding='utf-8') as f:\n        json.dump(file_structure, f, ensure_ascii=False, indent=4)\n    print(f\"Directory structure and file contents saved to {output_filename}\")\n\nif __name__ == \"__main__\":\n    base_path = '.'  # Current directory\n    structure_with_files = collect_directory_structure_and_files(base_path)\n    save_directory_structure_and_files(structure_with_files)",
            "requirements.txt": "python-telegram-bot\nrequests\npython-dotenv",
            "directory_structure_with_files.json": "{\n    \"\": {\n        \"directories\": [\n            \".pytest_cache\",\n            \"tests\",\n            \"scripts\",\n            \"commands\",\n            \".git\",\n            \".vscode\"\n        ],\n        \"files\": {\n            \"collect_structure_and_files.py\": \"import os\\nimport json\\nfrom gitignore_parser import parse_gitignore\\n\\ndef collect_directory_structure_and_files(base_path='.'):\\n    file_structure = {}\\n    \\n    # Parse .gitignore file if it exists\\n    gitignore_file = os.path.join(base_path, '.gitignore')\\n    if os.path.exists(gitignore_file):\\n        is_ignored = parse_gitignore(gitignore_file)\\n    else:\\n        is_ignored = lambda path: False  # No gitignore file, don't ignore anything\\n\\n    # Walk through all directories and files starting from base_path\\n    for root, dirs, files in os.walk(base_path):\\n        # Skip files that match .gitignore\\n        dirs[:] = [d for d in dirs if not is_ignored(os.path.join(root, d))]\\n        files = [f for f in files if not is_ignored(os.path.join(root, f))]\\n        \\n        # Get the relative path\\n        relative_root = os.path.relpath(root, base_path)\\n        \\n        if relative_root == '.':\\n            relative_root = ''\\n        \\n        # Store the directory and file structure\\n        file_structure[relative_root] = {\\n            'directories': dirs,\\n            'files': {}\\n        }\\n        \\n        for file in files:\\n            file_path = os.path.join(root, file)\\n            \\n            # Skip non-code files or files that can't be read\\n            if file.endswith(('.py', '.txt', '.md', '.json', '.yml', '.yaml')):  # Add more extensions as needed\\n                try:\\n                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\\n                        file_structure[relative_root]['files'][file] = f.read()\\n                except Exception as e:\\n                    print(f\\\"Could not read {file_path}: {e}\\\")\\n    \\n    return file_structure\\n\\ndef save_directory_structure_and_files(file_structure, output_filename=\\\"directory_structure_with_files.json\\\"):\\n    # Save the directory structure and file contents to a JSON file\\n    with open(output_filename, 'w', encoding='utf-8') as f:\\n        json.dump(file_structure, f, ensure_ascii=False, indent=4)\\n    print(f\\\"Directory structure and file contents saved to {output_filename}\\\")\\n\\nif __name__ == \\\"__main__\\\":\\n    base_path = '.'  # Current directory\\n    structure_with_files = collect_directory_structure_and_files(base_path)\\n    save_directory_structure_and_files(structure_with_files)\",\n            \"requirements.txt\": \"python-telegram-bot\\nrequests\\npython-dotenv\",\n            \"device_list.txt\": \"\",\n            \"logger.py\": \"import os\\nfrom datetime import datetime\\nfrom bot_utils import load_whitelist\\n\\nBOT_WHITELIST_FILE = \\\"bot_whitelist.txt\\\"\\n\\n# Log user requests\\nasync def log_request(user_id, username, command):  # ✅ Ensure it expects three arguments\\n    timestamp = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n    log_entry = f\\\"[{timestamp}] {username} ({user_id}) used: {command}\\\\n\\\"\\n\\n    with open(\\\"bot_requests.log\\\", \\\"a\\\") as log_file:\\n        log_file.write(log_entry)\\n\\n    # Check if the user is in the whitelist\\n    bot_whitelist = load_whitelist(BOT_WHITELIST_FILE)\\n    if str(user_id) not in bot_whitelist:\\n        print(f\\\"🚨 Unauthorized access attempt: {username} ({user_id}) tried {command}\\\")\",\n            \"README.md\": \"# pi_ip_bot\\n\\n\\ntest\\n\",\n            \"piipbot.py\": \"import os\\nimport importlib\\nimport logging\\nfrom dotenv import load_dotenv\\nfrom telegram import Update, ReplyKeyboardRemove\\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandler, ConversationHandler\\nfrom commands.admin import handle_approval, handle_approval_callback\\nfrom commands.start import start_command\\nfrom commands.menu import menu_command, handle_menu_buttons, vpn_menu, get_main_menu, get_conversation_handler\\nfrom commands.vpn.devices import add_device, list_devices, get_config, remove_device\\nfrom bot_utils import is_user_authorized, request_approval\\n\\n# Load environment variables\\nload_dotenv()\\nBOT_TOKEN = os.getenv(\\\"BOT_TOKEN\\\")\\nADMIN_ID = os.getenv(\\\"ADMIN_ID\\\")\\n\\nif not ADMIN_ID:\\n    raise ValueError(\\\"ADMIN_ID is not set in the environment variables.\\\")\\n\\n# Function to dynamically load command handlers from the \\\"commands\\\" folder\\ndef load_commands():\\n    commands = {}\\n    commands_dir = \\\"commands\\\"\\n\\n    for filename in os.listdir(commands_dir):\\n        if filename.endswith(\\\".py\\\") and filename != \\\"__init__.py\\\":\\n            module_name = f\\\"{commands_dir}.{filename[:-3]}\\\"  # Remove .py extension\\n            module = importlib.import_module(module_name)\\n\\n            if hasattr(module, f\\\"{filename[:-3]}_command\\\"):\\n                commands[filename[:-3]] = getattr(module, f\\\"{filename[:-3]}_command\\\")\\n\\n    return commands\\n\\n# Main function to start the bot\\ndef main():\\n    app = Application.builder().token(BOT_TOKEN).build()\\n\\n    # Dynamically load all command handlers\\n    commands = load_commands()\\n    for cmd_name, cmd_func in commands.items():\\n        app.add_handler(CommandHandler(cmd_name, cmd_func))\\n        print(f\\\"✅ Loaded command: /{cmd_name}\\\")\\n\\n    # Add start command and button handler\\n    app.add_handler(CommandHandler(\\\"start\\\", start))\\n    app.add_handler(get_conversation_handler())\\n    app.add_handler(CallbackQueryHandler(handle_menu_buttons, pattern='^(?!approve|deny).*$'))\\n    app.add_handler(CallbackQueryHandler(handle_approval_callback, pattern='^(approve|deny):'))\\n    app.add_handler(CallbackQueryHandler(handle_menu_buttons, pattern='^remove_device:'))\\n\\n    # Register VPN commands\\n    app.add_handler(CommandHandler(\\\"vpn\\\", vpn_menu))\\n    app.add_handler(CommandHandler(\\\"add_device\\\", add_device))\\n    app.add_handler(CommandHandler(\\\"list_devices\\\", list_devices))\\n    app.add_handler(CommandHandler(\\\"get_config\\\", get_config))\\n    app.add_handler(CommandHandler(\\\"remove_device\\\", remove_device))\\n\\n    # Register approval handler\\n    app.add_handler(MessageHandler(filters.ALL, handle_approval))\\n\\n    print(\\\"🤖 Bot is running...\\\")\\n    app.run_polling()\\n\\nasync def start(update: Update, context):\\n    user_id = str(update.message.from_user.id)\\n    username = update.message.from_user.username or \\\"Unknown\\\"\\n\\n    logging.info(f\\\"Checking authorization for user ID: {user_id}, Username: {username}\\\")\\n\\n    if not is_user_authorized(user_id):\\n        await request_approval(user_id, username, \\\"bot\\\")\\n        await update.message.reply_text(\\\"🚫 You are not authorized to use this bot. An approval request has been sent to the admin.\\\")\\n        return\\n\\n    await update.message.reply_text(\\n        \\\"👋 Welcome to Pi IP Bot! Use the menu to select a command.\\\",\\n        reply_markup=ReplyKeyboardRemove()\\n    )\\n    await update.message.reply_text(\\n        \\\"📍 Main Menu:\\\",\\n        reply_markup=get_main_menu()\\n    )\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\",\n            \"bot_utils.py\": \"import os\\nimport logging\\nfrom telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup\\n\\nADMIN_ID = os.getenv(\\\"ADMIN_ID\\\")\\n\\ndef load_whitelist(filename):\\n    if not os.path.exists(filename):\\n        return set()\\n    with open(filename, \\\"r\\\") as f:\\n        return set(line.strip().split()[0] for line in f if line.strip())\\n\\ndef add_to_whitelist(filename, user_id, username=None):\\n    with open(filename, \\\"a\\\") as f:\\n        if username:\\n            f.write(f\\\"{user_id}  # {username}\\\\n\\\")\\n        else:\\n            f.write(f\\\"{user_id}\\\\n\\\")\\n\\ndef is_user_in_whitelist(filename, user_id):\\n    whitelist = load_whitelist(filename)\\n    return str(user_id) in whitelist\\n\\ndef check_whitelist(user_id):\\n    return is_user_in_whitelist(BOT_WHITELIST_FILE, user_id)\\n\\nBOT_WHITELIST_FILE = \\\"bot_whitelist.txt\\\"\\nVPN_WHITELIST_FILE = \\\"vpn_whitelist.txt\\\"\\n\\nVPN_WHITELIST = load_whitelist(VPN_WHITELIST_FILE)\\n\\ndef is_user_in_bot_whitelist(user_id):\\n    return is_user_in_whitelist(BOT_WHITELIST_FILE, user_id)\\n\\ndef is_user_in_vpn_whitelist(user_id):\\n    return is_user_in_whitelist(VPN_WHITELIST_FILE, user_id)\\n\\ndef add_user_to_bot_whitelist(user_id, username=None):\\n    add_to_whitelist(BOT_WHITELIST_FILE, user_id, username)\\n\\ndef add_to_vpn_whitelist(user_id, username=None):\\n    add_to_whitelist(VPN_WHITELIST_FILE, user_id, username)\\n\\ndef is_user_authorized(user_id):\\n    authorized_users = load_whitelist(BOT_WHITELIST_FILE)\\n    logging.info(f\\\"Authorized users: {authorized_users}\\\")\\n    return user_id in authorized_users\\n\\nasync def request_approval(user_id, username, approval_type):\\n    bot = Bot(token=os.getenv(\\\"BOT_TOKEN\\\"))\\n    admin_id = os.getenv(\\\"ADMIN_ID\\\")\\n    if not admin_id:\\n        raise ValueError(\\\"ADMIN_ID is not set in the environment variables.\\\")\\n    message = f\\\"🚨 Approval request for {approval_type} access:\\\\nUser ID: {user_id}\\\\nUsername: @{username}\\\"\\n    keyboard = [\\n        [\\n            InlineKeyboardButton(\\\"Approve\\\", callback_data=f\\\"approve:{user_id}:{username}:{approval_type}\\\"),\\n            InlineKeyboardButton(\\\"Deny\\\", callback_data=f\\\"deny:{user_id}:{username}:{approval_type}\\\")\\n        ]\\n    ]\\n    reply_markup = InlineKeyboardMarkup(keyboard)\\n    await bot.send_message(chat_id=admin_id, text=message, reply_markup=reply_markup)\\n\"\n        }\n    },\n    \".pytest_cache\": {\n        \"directories\": [\n            \"v\"\n        ],\n        \"files\": {\n            \"README.md\": \"# pytest cache directory #\\n\\nThis directory contains data from the pytest's cache plugin,\\nwhich provides the `--lf` and `--ff` options, as well as the `cache` fixture.\\n\\n**Do not** commit this to version control.\\n\\nSee [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.\\n\"\n        }\n    },\n    \".pytest_cache/v\": {\n        \"directories\": [\n            \"cache\"\n        ],\n        \"files\": {}\n    },\n    \".pytest_cache/v/cache\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \"tests\": {\n        \"directories\": [],\n        \"files\": {\n            \"test_bot.py\": \"import pytest\\nimport asyncio\\nimport sys\\nimport os\\nfrom telegram import Update, User, Message, Chat, CallbackQuery\\nfrom telegram.ext import CallbackContext\\n\\n# Добавляем корневую директорию проекта в sys.path\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\\n\\nfrom bot_utils import is_user_authorized, request_approval, add_to_whitelist, BOT_WHITELIST_FILE, VPN_WHITELIST_FILE\\nfrom commands.menu import menu_command, vpn_menu\\nfrom commands.admin import handle_approval_callback\\n\\n@pytest.fixture\\ndef mock_update():\\n    user = User(id=12345, first_name=\\\"Test\\\", is_bot=False)\\n    chat = Chat(id=67890, type=\\\"private\\\")\\n    message = Message(message_id=1, date=None, chat=chat, text=\\\"/start\\\", from_user=user)\\n    return Update(update_id=1, message=message)\\n\\n@pytest.fixture\\ndef mock_context(mock_update):\\n    return CallbackContext.from_update(mock_update, None)\\n\\n@pytest.fixture\\ndef mock_callback_query():\\n    user = User(id=12345, first_name=\\\"Test\\\", is_bot=False)\\n    chat = Chat(id=67890, type=\\\"private\\\")\\n    message = Message(message_id=1, date=None, chat=chat, text=\\\"/start\\\", from_user=user)\\n    return CallbackQuery(id=1, from_user=user, message=message, chat_instance=\\\"instance\\\", data=\\\"\\\")\\n\\n@pytest.mark.asyncio\\nasync def test_menu_command_authorized(mock_update, mock_context, monkeypatch):\\n    def mock_is_user_authorized(user_id):\\n        return True\\n\\n    monkeypatch.setattr('bot_utils.is_user_authorized', mock_is_user_authorized)\\n    await menu_command(mock_update, mock_context)\\n    assert mock_update.message.reply_text.call_count == 2\\n\\n@pytest.mark.asyncio\\nasync def test_menu_command_unauthorized(mock_update, mock_context, monkeypatch):\\n    def mock_is_user_authorized(user_id):\\n        return False\\n\\n    async def mock_request_approval(user_id, username, approval_type):\\n        pass\\n\\n    monkeypatch.setattr('bot_utils.is_user_authorized', mock_is_user_authorized)\\n    monkeypatch.setattr('bot_utils.request_approval', mock_request_approval)\\n    await menu_command(mock_update, mock_context)\\n    assert mock_update.message.reply_text.call_count == 1\\n\\n@pytest.mark.asyncio\\nasync def test_vpn_menu_authorized(mock_update, mock_context, monkeypatch):\\n    def mock_is_user_in_vpn_whitelist(user_id):\\n        return True\\n\\n    monkeypatch.setattr('bot_utils.is_user_in_vpn_whitelist', mock_is_user_in_vpn_whitelist)\\n    await vpn_menu(mock_update, mock_context)\\n    assert mock_update.message.reply_text.call_count == 1\\n\\n@pytest.mark.asyncio\\nasync def test_vpn_menu_unauthorized(mock_update, mock_context, monkeypatch):\\n    def mock_is_user_in_vpn_whitelist(user_id):\\n        return False\\n\\n    async def mock_request_approval(user_id, username, approval_type):\\n        pass\\n\\n    monkeypatch.setattr('bot_utils.is_user_in_vpn_whitelist', mock_is_user_in_vpn_whitelist)\\n    monkeypatch.setattr('bot_utils.request_approval', mock_request_approval)\\n    await vpn_menu(mock_update, mock_context)\\n    assert mock_update.message.reply_text.call_count == 1\\n\\n@pytest.mark.asyncio\\nasync def test_handle_approval_callback_approve_bot(mock_context, monkeypatch):\\n    user = User(id=12345, first_name=\\\"Test\\\", is_bot=False)\\n    chat = Chat(id=67890, type=\\\"private\\\")\\n    message = Message(message_id=1, date=None, chat=chat, text=\\\"/start\\\", from_user=user)\\n    callback_query = CallbackQuery(id=1, from_user=user, message=message, chat_instance=\\\"instance\\\", data=\\\"approve:12345:TestUser:bot\\\")\\n    update = Update(update_id=1, callback_query=callback_query)\\n\\n    def mock_add_to_whitelist(filename, user_id, username):\\n        assert filename == BOT_WHITELIST_FILE\\n        assert user_id == \\\"12345\\\"\\n        assert username == \\\"TestUser\\\"\\n\\n    monkeypatch.setattr('bot_utils.add_to_whitelist', mock_add_to_whitelist)\\n    await handle_approval_callback(update, mock_context)\\n    assert update.callback_query.edit_message_text.call_count == 1\\n\\n@pytest.mark.asyncio\\nasync def test_handle_approval_callback_approve_vpn(mock_context, monkeypatch):\\n    user = User(id=12345, first_name=\\\"Test\\\", is_bot=False)\\n    chat = Chat(id=67890, type=\\\"private\\\")\\n    message = Message(message_id=1, date=None, chat=chat, text=\\\"/start\\\", from_user=user)\\n    callback_query = CallbackQuery(id=1, from_user=user, message=message, chat_instance=\\\"instance\\\", data=\\\"approve:12345:TestUser:vpn\\\")\\n    update = Update(update_id=1, callback_query=callback_query)\\n\\n    def mock_add_to_whitelist(filename, user_id, username):\\n        assert filename == VPN_WHITELIST_FILE\\n        assert user_id == \\\"12345\\\"\\n        assert username == \\\"TestUser\\\"\\n\\n    monkeypatch.setattr('bot_utils.add_to_whitelist', mock_add_to_whitelist)\\n    await handle_approval_callback(update, mock_context)\\n    assert update.callback_query.edit_message_text.call_count == 1\\n\\n@pytest.mark.asyncio\\nasync def test_handle_approval_callback_deny(mock_context):\\n    user = User(id=12345, first_name=\\\"Test\\\", is_bot=False)\\n    chat = Chat(id=67890, type=\\\"private\\\")\\n    message = Message(message_id=1, date=None, chat=chat, text=\\\"/start\\\", from_user=user)\\n    callback_query = CallbackQuery(id=1, from_user=user, message=message, chat_instance=\\\"instance\\\", data=\\\"deny:12345:TestUser:bot\\\")\\n    update = Update(update_id=1, callback_query=callback_query)\\n\\n    await handle_approval_callback(update, mock_context)\\n    assert update.callback_query.edit_message_text.call_count == 1\\n\"\n        }\n    },\n    \"scripts\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \"commands\": {\n        \"directories\": [\n            \"vpn\"\n        ],\n        \"files\": {\n            \"start.py\": \"from telegram import Update, ReplyKeyboardRemove\\nfrom telegram.ext import CallbackContext\\nfrom commands.menu import get_main_menu\\nfrom logger import log_request\\n\\nasync def start_command(update: Update, context: CallbackContext) -> None:\\n    user_id = str(update.message.from_user.id)\\n    username = update.message.from_user.username or \\\"Unknown\\\"\\n\\n    await log_request(user_id, username, \\\"/start\\\")\\n\\n    await update.message.reply_text(\\n        \\\"👋 Welcome to Pi IP Bot! Use the menu to select a command.\\\",\\n        reply_markup=ReplyKeyboardRemove()\\n    )\\n    await update.message.reply_text(\\n        \\\"📍 Main Menu:\\\",\\n        reply_markup=get_main_menu()\\n    )\",\n            \"menu.py\": \"from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup\\nfrom telegram.ext import CallbackContext, ConversationHandler, CommandHandler, MessageHandler, filters\\nfrom bot_utils import is_user_in_vpn_whitelist, is_user_authorized, request_approval\\nfrom commands.vpn.devices import add_device, list_devices, get_config, remove_device\\nfrom commands.ip import ip_command\\nfrom commands.uptime import uptime_command\\nimport logging\\n\\n# Define states for the conversation\\nDEVICE_NAME, REMOVE_DEVICE_NAME = range(2)\\n\\ndef get_main_menu():\\n    return ReplyKeyboardMarkup([\\n        [\\\"🌐 IP\\\", \\\"⏳ Uptime\\\"],\\n        [\\\"🔐 VPN\\\"]\\n    ], resize_keyboard=True, one_time_keyboard=True)\\n\\ndef get_vpn_menu():\\n    return ReplyKeyboardMarkup([\\n        [\\\"➕ Add Device\\\", \\\"📋 List Devices\\\"],\\n        [\\\"🔑 Get Config\\\", \\\"❌ Remove Device\\\"],\\n        [\\\"🔙 Main Menu\\\"]\\n    ], resize_keyboard=True, one_time_keyboard=True)\\n\\nasync def menu_command(update: Update, context: CallbackContext) -> None:\\n    user_id = str(update.message.from_user.id)\\n    username = update.message.from_user.username or \\\"Unknown\\\"\\n\\n    if not is_user_authorized(user_id):\\n        await request_approval(user_id, username, \\\"bot\\\")\\n        await update.message.reply_text(\\\"🚫 You are not authorized to use this bot. An approval request has been sent to the admin.\\\")\\n        return\\n\\n    await update.message.reply_text(\\n        \\\"📍 Main Menu:\\\",\\n        reply_markup=ReplyKeyboardRemove()\\n    )\\n    await update.message.reply_text(\\n        \\\"📍 Main Menu:\\\",\\n        reply_markup=get_main_menu()\\n    )\\n\\nasync def vpn_menu(update: Update, context: CallbackContext) -> None:\\n    user_id = str(update.message.from_user.id)\\n    username = update.message.from_user.username or \\\"Unknown\\\"\\n\\n    logging.info(f\\\"Checking VPN authorization for user ID: {user_id}, Username: {username}\\\")\\n\\n    if not is_user_in_vpn_whitelist(user_id):\\n        await request_approval(user_id, username, \\\"vpn\\\")\\n        await update.message.reply_text(\\\"❌ You are not authorized for VPN access. An approval request has been sent to the admin.\\\")\\n        return\\n\\n    await update.message.reply_text(\\\"🔐 VPN Menu:\\\", reply_markup=get_vpn_menu())\\n\\nasync def handle_menu_buttons(update: Update, context: CallbackContext) -> None:\\n    if update.message:\\n        text = update.message.text.strip()\\n        message = update.message\\n    elif update.callback_query:\\n        text = update.callback_query.data\\n        message = update.callback_query.message\\n    else:\\n        return\\n\\n    context.args = text.split()\\n\\n    if text == \\\"🌐 IP\\\":\\n        await ip_command(update, context)\\n    elif text == \\\"⏳ Uptime\\\":\\n        await uptime_command(update, context)\\n    elif text == \\\"🔐 VPN\\\":\\n        await vpn_menu(update, context)\\n    elif text == \\\"➕ Add Device\\\":\\n        await update.message.reply_text(\\\"Please enter the device name:\\\")\\n        return DEVICE_NAME\\n    elif text == \\\"📋 List Devices\\\":\\n        await list_devices(update, context)\\n    elif text == \\\"🔑 Get Config\\\":\\n        await get_config(update, context)\\n    elif text == \\\"❌ Remove Device\\\":\\n        await update.message.reply_text(\\\"Please enter the device name to remove:\\\")\\n        return REMOVE_DEVICE_NAME\\n    elif text.startswith(\\\"remove_device:\\\"):\\n        device_name = text.split(\\\":\\\")[1]\\n        context.args = [device_name]\\n        await remove_device(update, context)\\n    elif text == \\\"🔙 Main Menu\\\":\\n        await menu_command(update, context)\\n    else:\\n        await message.reply_text(\\\"❌ Unknown command. Please use the menu or type /help for available commands.\\\")\\n\\nasync def device_name_handler(update: Update, context: CallbackContext) -> None:\\n    device_name = update.message.text.strip()\\n    context.args = [device_name]\\n    await add_device(update, context)\\n    return ConversationHandler.END\\n\\nasync def remove_device_name_handler(update: Update, context: CallbackContext) -> None:\\n    device_name = update.message.text.strip()\\n    context.args = [device_name]\\n    await remove_device(update, context)\\n    return ConversationHandler.END\\n\\nasync def cancel(update: Update, context: CallbackContext) -> None:\\n    await update.message.reply_text(\\\"Operation cancelled.\\\", reply_markup=get_main_menu())\\n    return ConversationHandler.END\\n\\ndef get_conversation_handler():\\n    return ConversationHandler(\\n        entry_points=[MessageHandler(filters.TEXT & ~filters.COMMAND, handle_menu_buttons)],\\n        states={\\n            DEVICE_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, device_name_handler)],\\n            REMOVE_DEVICE_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, remove_device_name_handler)]\\n        },\\n        fallbacks=[CommandHandler(\\\"cancel\\\", cancel)]\\n    )\",\n            \"admin.py\": \"import logging\\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\\nfrom telegram.ext import CallbackContext\\nfrom bot_utils import add_to_whitelist, is_user_authorized, request_approval, BOT_WHITELIST_FILE, VPN_WHITELIST_FILE\\n\\nasync def handle_approval(update: Update, context: CallbackContext) -> None:\\n    user_id = str(update.message.from_user.id)\\n    username = update.message.from_user.username or \\\"Unknown\\\"\\n\\n    if not is_user_authorized(user_id):\\n        await request_approval(user_id, username, \\\"bot\\\")\\n        await update.message.reply_text(\\\"🚫 You are not authorized to use this bot. An approval request has been sent to the admin.\\\")\\n    else:\\n        await update.message.reply_text(\\\"✅ You are authorized to use this bot.\\\")\\n        add_to_whitelist(BOT_WHITELIST_FILE, user_id, username)\\n\\nasync def handle_approval_callback(update: Update, context: CallbackContext) -> None:\\n    query = update.callback_query\\n    await query.answer()\\n    data = query.data.split(':')\\n    action = data[0]\\n    user_id = data[1]\\n    username = data[2]\\n    approval_type = data[3]\\n\\n    logging.info(f\\\"Approval action: {action}, User ID: {user_id}, Username: {username}, Type: {approval_type}\\\")\\n\\n    if action == 'approve':\\n        if approval_type == 'bot':\\n            add_to_whitelist(BOT_WHITELIST_FILE, user_id, username)\\n        elif approval_type == 'vpn':\\n            add_to_whitelist(VPN_WHITELIST_FILE, user_id, username)\\n        await query.edit_message_text(f\\\"✅ User @{username} (ID: {user_id}) has been approved for {approval_type} access.\\\")\\n    elif action == 'deny':\\n        await query.edit_message_text(f\\\"❌ User @{username} (ID: {user_id}) has been denied for {approval_type} access.\\\")\",\n            \"ip.py\": \"import requests\\nfrom telegram import Update\\nfrom telegram.ext import CallbackContext\\nfrom bot_utils import is_user_authorized, request_approval\\n\\nasync def ip_command(update: Update, context: CallbackContext) -> None:\\n    user_id = str(update.message.from_user.id)\\n    username = update.message.from_user.username or \\\"Unknown\\\"\\n\\n    if not is_user_authorized(user_id):\\n        await request_approval(user_id, username, \\\"bot\\\")\\n        await update.message.reply_text(\\\"🚫 You are not authorized to use this bot. An approval request has been sent to the admin.\\\")\\n        return\\n\\n    await update.message.reply_text(\\\"📡 Fetching your IP address...\\\")\\n\\n    try:\\n        response = requests.get(\\\"https://api64.ipify.org?format=json\\\", timeout=5)\\n        response.raise_for_status()  # Raise an error for bad responses\\n        ip_data = response.json()\\n        public_ip = ip_data.get(\\\"ip\\\", \\\"Unknown\\\")\\n\\n        await update.message.reply_text(f\\\"🌐 Your public IP address: `{public_ip}`\\\", parse_mode=\\\"Markdown\\\")\\n    except requests.RequestException:\\n        await update.message.reply_text(\\\"⚠️ Error: Unable to fetch public IP.\\\")\",\n            \"uptime.py\": \"import subprocess\\nfrom telegram import Update\\nfrom telegram.ext import CallbackContext\\nfrom bot_utils import is_user_authorized, request_approval\\nfrom logger import log_request\\n\\nasync def uptime_command(update: Update, context: CallbackContext) -> None:\\n    user_id = str(update.message.from_user.id)\\n    username = update.message.from_user.username or \\\"Unknown\\\"\\n\\n    if not is_user_authorized(user_id):\\n        await request_approval(user_id, username, \\\"bot\\\")\\n        await update.message.reply_text(\\\"🚫 You are not authorized to use this bot. An approval request has been sent to the admin.\\\")\\n        return\\n\\n    await log_request(user_id, username, \\\"/uptime\\\")\\n\\n    try:\\n        # Get system uptime\\n        uptime_output = subprocess.check_output(\\\"uptime -p\\\", shell=True).decode().strip()\\n        await update.message.reply_text(f\\\"⏳ Server Uptime: `{uptime_output}`\\\", parse_mode=\\\"Markdown\\\")\\n\\n    except subprocess.CalledProcessError as e:\\n        await update.message.reply_text(\\\"❌ Error: Unable to fetch system uptime.\\\")\\n        print(f\\\"ERROR: Failed to fetch uptime - {e}\\\")  # Log the error\"\n        }\n    },\n    \"commands/vpn\": {\n        \"directories\": [],\n        \"files\": {\n            \"config.py\": \"import os\\n\\nWIREGUARD_DIR = \\\"/etc/wireguard\\\"\\nCLIENTS_DIR = f\\\"{WIREGUARD_DIR}/clients\\\"\\nWG_CONFIG_PATH = f\\\"{WIREGUARD_DIR}/wg0.conf\\\"\\n\\ndef generate_vpn_config(username, device_name):\\n    \\\"\\\"\\\"Generate a WireGuard configuration file for a user.\\\"\\\"\\\"\\n    client_private_key = os.popen(\\\"wg genkey\\\").read().strip()\\n    client_public_key = os.popen(f\\\"echo '{client_private_key}' | wg pubkey\\\").read().strip()\\n\\n    server_public_key = open(f\\\"{WIREGUARD_DIR}/server_public.key\\\", \\\"r\\\").read().strip()\\n    client_ip = f\\\"10.0.0.{100 + hash(username) % 100}/24\\\"\\n\\n    config_content = f\\\"\\\"\\\"[Interface]\\nPrivateKey = {client_private_key}\\nAddress = {client_ip}\\nDNS = 1.1.1.1\\n\\n[Peer]\\nPublicKey = {server_public_key}\\nEndpoint = ashavskiy.keenetic.name:51820\\nAllowedIPs = 0.0.0.0/0, ::/0\\nPersistentKeepalive = 25\\n\\\"\\\"\\\"\\n\\n    os.system(f\\\"sudo mkdir -p {CLIENTS_DIR}\\\")\\n    config_path = f\\\"{CLIENTS_DIR}/{username}_{device_name}.conf\\\"\\n\\n    with open(config_path, \\\"w\\\") as f:\\n        f.write(config_content)\\n\\n    os.system(f\\\"sudo chmod 600 {config_path}\\\")\\n    os.system(f\\\"echo '\\\\n[Peer]\\\\nPublicKey = {client_public_key}\\\\nAllowedIPs = {client_ip}' | sudo tee -a {WG_CONFIG_PATH}\\\")\\n    os.system(\\\"sudo systemctl restart wg-quick@wg0\\\")\\n\\n    return config_path\",\n            \"request.py\": \"from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton\\nfrom telegram.ext import CallbackContext\\nfrom bot_utils import VPN_WHITELIST, add_to_vpn_whitelist\\nimport os\\n\\nADMIN_ID = os.getenv(\\\"ADMIN_ID\\\")\\n\\nasync def request_vpn(update: Update, context: CallbackContext) -> None:\\n    \\\"\\\"\\\"Handle user VPN access requests.\\\"\\\"\\\"\\n    user_id = str(update.message.from_user.id)\\n    username = update.message.from_user.username or f\\\"User_{user_id}\\\"\\n\\n    if user_id in VPN_WHITELIST:\\n        await update.message.reply_text(\\\"✅ You already have VPN access.\\\")\\n        return\\n\\n    keyboard = [\\n        [InlineKeyboardButton(\\\"✅ Approve\\\", callback_data=f\\\"vpn_approve_{user_id}_{username}\\\")],\\n        [InlineKeyboardButton(\\\"❌ Deny\\\", callback_data=f\\\"vpn_deny_{user_id}\\\")]\\n    ]\\n    reply_markup = InlineKeyboardMarkup(keyboard)\\n\\n    await context.bot.send_message(chat_id=ADMIN_ID, text=f\\\"🚨 New VPN request!\\\\n\\\\nUsername: @{username}\\\\nUser ID: {user_id}\\\", reply_markup=reply_markup)\\n    await update.message.reply_text(\\\"📨 VPN request sent to the admin. Please wait for approval.\\\")\",\n            \"__init__.py\": \"from .request import request_vpn\\nfrom .approval import handle_vpn_approval  # ✅ Ensure approval function is properly imported\\nfrom .config import generate_vpn_config\\nfrom .devices import add_device, list_devices, remove_device, get_config\\n\\n__all__ = [\\n    \\\"request_vpn\\\",\\n    \\\"handle_vpn_approval\\\",\\n    \\\"generate_vpn_config\\\",\\n    \\\"add_device\\\",\\n    \\\"list_devices\\\",\\n    \\\"remove_device\\\",\\n    \\\"get_config\\\",\\n]\",\n            \"approval.py\": \"from telegram import Update\\nfrom telegram.ext import CallbackContext\\nfrom bot_utils import add_to_vpn_whitelist\\n\\nasync def handle_vpn_approval(update: Update, context: CallbackContext) -> None:\\n    \\\"\\\"\\\"Handles admin approval or denial of VPN requests.\\\"\\\"\\\"\\n    query = update.callback_query\\n    await query.answer()\\n\\n    callback_data = query.data.split(\\\"_\\\")\\n    action = callback_data[1]\\n    user_id = callback_data[2]\\n    username = callback_data[3] if action == \\\"approve\\\" else None\\n\\n    if action == \\\"approve\\\":\\n        add_to_vpn_whitelist(user_id, username)\\n        await query.edit_message_text(f\\\"✅ User @{username} ({user_id}) has been approved for VPN access.\\\")\\n        await context.bot.send_message(chat_id=user_id, text=\\\"🎉 You have been approved for VPN access! Use /adddevice to generate a configuration.\\\")\\n    else:\\n        await query.edit_message_text(f\\\"❌ User {user_id} was denied VPN access.\\\")\",\n            \"devices.py\": \"import os\\nimport subprocess\\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\\nfrom telegram.ext import CallbackContext\\nfrom bot_utils import VPN_WHITELIST_FILE, load_whitelist\\nfrom dotenv import load_dotenv\\n\\n# Load environment variables\\nload_dotenv()\\n\\nPRIVATE_KEY = os.getenv(\\\"PRIVATE_KEY\\\")\\nSERVER_PUBLIC_KEY = os.getenv(\\\"SERVER_PUBLIC_KEY\\\")\\nSERVER_IP = os.getenv(\\\"SERVER_IP\\\")\\n\\nif not SERVER_PUBLIC_KEY:\\n    raise ValueError(\\\"SERVER_PUBLIC_KEY is not set in the .env file\\\")\\n\\ndef save_whitelist(filename, data):\\n    with open(filename, \\\"a\\\") as file:\\n        file.write(data + \\\"\\\\n\\\")\\n\\nDEVICE_LIST_DIR = \\\"device_lists\\\"\\nVPN_CONFIG_DIR = \\\"/etc/wireguard/clients\\\"\\n\\ndef get_device_list_file(username):\\n    return os.path.join(DEVICE_LIST_DIR, f\\\"devices.{username}.txt\\\")\\n\\ndef get_next_ip():\\n    # Call a helper script to get the next available IP address\\n    script_path = os.path.join(os.path.dirname(__file__), '..', '..', 'scripts', 'get_next_ip.sh')\\n    result = subprocess.check_output([\\\"sudo\\\", script_path]).strip().decode('utf-8')\\n    return result\\n\\ndef save_device_list(filename, username, device_name, remove=False):\\n    # Ensure the directory exists\\n    os.makedirs(os.path.dirname(filename), exist_ok=True)\\n    if remove:\\n        with open(filename, \\\"r\\\") as file:\\n            lines = file.readlines()\\n        with open(filename, \\\"w\\\") as file:\\n            for line in lines:\\n                if line.strip() != f\\\"{username}_{device_name}\\\":\\n                    file.write(line)\\n    else:\\n        with open(filename, \\\"a\\\") as file:\\n            file.write(f\\\"{username}_{device_name}\\\\n\\\")\\n\\nasync def list_devices(update: Update, context: CallbackContext) -> None:\\n    user_id = str(update.message.from_user.id)\\n    username = update.message.from_user.username or f\\\"User_{user_id}\\\"\\n    user_devices = []\\n    if os.path.exists(VPN_WHITELIST_FILE):\\n        with open(VPN_WHITELIST_FILE, \\\"r\\\") as file:\\n            for line in file:\\n                if line.startswith(username):\\n                    parts = line.strip().split()\\n                    if len(parts) > 1:\\n                        user_devices.append(parts[1])\\n    if user_devices:\\n        keyboard = [[InlineKeyboardButton(device, callback_data=f\\\"remove_device:{device}\\\") for device in user_devices]]\\n        reply_markup = InlineKeyboardMarkup(keyboard)\\n        await update.message.reply_text(\\\"📋 Your devices:\\\", reply_markup=reply_markup)\\n    else:\\n        await update.message.reply_text(\\\"❌ No devices found.\\\")\\n\\nasync def add_device(update: Update, context: CallbackContext) -> None:\\n    user_id = str(update.message.from_user.id)\\n    username = update.message.from_user.username or f\\\"User_{user_id}\\\"\\n    if len(context.args) == 0:\\n        await update.message.reply_text(\\\"❌ Please specify a device name.\\\")\\n        return\\n    device_name = context.args[0]\\n\\n    # Generate a new key pair for the device\\n    private_key = subprocess.check_output([\\\"wg\\\", \\\"genkey\\\"]).strip().decode('utf-8')\\n    public_key = subprocess.check_output([\\\"wg\\\", \\\"pubkey\\\"], input=private_key.encode('utf-8')).strip().decode('utf-8')\\n\\n    # Get the next available IP address\\n    device_ip = get_next_ip()\\n\\n    device_config = os.path.join(VPN_CONFIG_DIR, f\\\"{username}_{device_name}.conf\\\")\\n    with open(device_config, \\\"w\\\") as f:\\n        f.write(f\\\"[Interface]\\\\nPrivateKey = {private_key}\\\\nAddress = {device_ip}/24\\\\n\\\\n[Peer]\\\\nPublicKey = {SERVER_PUBLIC_KEY}\\\\nEndpoint = {SERVER_IP}:51820\\\\nAllowedIPs = 0.0.0.0/0, ::/0\\\\n\\\")\\n    save_whitelist(VPN_WHITELIST_FILE, f\\\"{username} {device_name}\\\")\\n    \\n    # Use a helper script to add device to wg0.conf and restart WireGuard\\n    script_path = os.path.join(os.path.dirname(__file__), '..', '..', 'scripts', 'helper_script.sh')\\n    subprocess.run([\\\"sudo\\\", script_path, \\\"add\\\", username, device_name, public_key, device_ip])\\n    \\n    await update.message.reply_document(open(device_config, \\\"rb\\\"), filename=f\\\"{username}_{device_name}.conf\\\")\\n\\nasync def remove_device(update: Update, context: CallbackContext) -> None:\\n    if update.message:\\n        user_id = str(update.message.from_user.id)\\n        username = update.message.from_user.username or f\\\"User_{user_id}\\\"\\n        reply_func = update.message.reply_text\\n    elif update.callback_query:\\n        user_id = str(update.callback_query.from_user.id)\\n        username = update.callback_query.from_user.username or f\\\"User_{user_id}\\\"\\n        reply_func = update.callback_query.message.reply_text\\n    else:\\n        return\\n\\n    if context.args is None or len(context.args) == 0:\\n        await reply_func(\\\"❌ Please specify a device name to remove.\\\")\\n        return\\n    device_name = context.args[0]\\n    device_config = os.path.join(VPN_CONFIG_DIR, f\\\"{username}_{device_name}.conf\\\")\\n    if os.path.exists(device_config):\\n        os.remove(device_config)\\n        \\n        # Remove device from whitelist\\n        if os.path.exists(VPN_WHITELIST_FILE):\\n            with open(VPN_WHITELIST_FILE, \\\"r\\\") as file:\\n                lines = file.readlines()\\n            with open(VPN_WHITELIST_FILE, \\\"w\\\") as file:\\n                for line in lines:\\n                    if line.strip() != f\\\"{username} {device_name}\\\":\\n                        file.write(line)\\n        \\n        # Use a helper script to remove device from wg0.conf and restart WireGuard\\n        script_path = os.path.join(os.path.dirname(__file__), '..', '..', 'scripts', 'helper_script.sh')\\n        subprocess.run([\\\"sudo\\\", script_path, \\\"remove\\\", username, device_name])\\n        await reply_func(f\\\"✅ Device {device_name} removed and WireGuard restarted.\\\")\\n    else:\\n        await reply_func(\\\"❌ Device not found.\\\")\\n\\nasync def get_config(update: Update, context: CallbackContext) -> None:\\n    user_id = str(update.message.from_user.id)\\n    username = update.message.from_user.username or f\\\"User_{user_id}\\\"\\n    if len(context.args) == 0:\\n        await update.message.reply_text(\\\"❌ Please specify a device name.\\\")\\n        return\\n    device_name = context.args[0]\\n    device_config = os.path.join(VPN_CONFIG_DIR, f\\\"{username}_{device_name}.conf\\\")\\n    if os.path.exists(device_config):\\n        await update.message.reply_document(open(device_config, \\\"rb\\\"), filename=f\\\"{username}_{device_name}.conf\\\")\\n    else:\\n        await update.message.reply_text(\\\"❌ Configuration file not found.\\\")\\n\"\n        }\n    },\n    \".git\": {\n        \"directories\": [\n            \"objects\",\n            \"info\",\n            \"logs\",\n            \"hooks\",\n            \"refs\"\n        ],\n        \"files\": {}\n    },\n    \".git/objects\": {\n        \"directories\": [\n            \"61\",\n            \"0d\",\n            \"95\",\n            \"59\",\n            \"92\",\n            \"0c\",\n            \"66\",\n            \"3e\",\n            \"50\",\n            \"68\",\n            \"57\",\n            \"3b\",\n            \"6f\",\n            \"03\",\n            \"9b\",\n            \"9e\",\n            \"04\",\n            \"6a\",\n            \"32\",\n            \"35\",\n            \"69\",\n            \"3c\",\n            \"56\",\n            \"51\",\n            \"3d\",\n            \"58\",\n            \"67\",\n            \"0b\",\n            \"93\",\n            \"94\",\n            \"0e\",\n            \"60\",\n            \"34\",\n            \"5a\",\n            \"5f\",\n            \"33\",\n            \"05\",\n            \"9d\",\n            \"9c\",\n            \"02\",\n            \"a4\",\n            \"a3\",\n            \"b5\",\n            \"b2\",\n            \"d9\",\n            \"ad\",\n            \"bb\",\n            \"d7\",\n            \"d0\",\n            \"be\",\n            \"b3\",\n            \"df\",\n            \"da\",\n            \"b4\",\n            \"a2\",\n            \"a5\",\n            \"bd\",\n            \"d1\",\n            \"d6\",\n            \"bc\",\n            \"ae\",\n            \"d8\",\n            \"ab\",\n            \"e5\",\n            \"e2\",\n            \"f4\",\n            \"f3\",\n            \"eb\",\n            \"c7\",\n            \"c0\",\n            \"ee\",\n            \"c9\",\n            \"fc\",\n            \"fd\",\n            \"f2\",\n            \"f5\",\n            \"e3\",\n            \"cf\",\n            \"ca\",\n            \"e4\",\n            \"fe\",\n            \"c8\",\n            \"fb\",\n            \"ed\",\n            \"c1\",\n            \"c6\",\n            \"ec\",\n            \"4e\",\n            \"20\",\n            \"18\",\n            \"27\",\n            \"4b\",\n            \"pack\",\n            \"7d\",\n            \"29\",\n            \"7c\",\n            \"16\",\n            \"42\",\n            \"89\",\n            \"45\",\n            \"1f\",\n            \"73\",\n            \"87\",\n            \"80\",\n            \"74\",\n            \"1a\",\n            \"28\",\n            \"17\",\n            \"7b\",\n            \"8f\",\n            \"8a\",\n            \"7e\",\n            \"10\",\n            \"19\",\n            \"4c\",\n            \"26\",\n            \"21\",\n            \"4d\",\n            \"75\",\n            \"81\",\n            \"86\",\n            \"72\",\n            \"44\",\n            \"2a\",\n            \"2f\",\n            \"43\",\n            \"88\",\n            \"9f\",\n            \"6b\",\n            \"07\",\n            \"38\",\n            \"00\",\n            \"6e\",\n            \"9a\",\n            \"36\",\n            \"5c\",\n            \"09\",\n            \"5d\",\n            \"31\",\n            \"info\",\n            \"91\",\n            \"65\",\n            \"62\",\n            \"96\",\n            \"3a\",\n            \"54\",\n            \"98\",\n            \"53\",\n            \"3f\",\n            \"30\",\n            \"5e\",\n            \"5b\",\n            \"37\",\n            \"08\",\n            \"6d\",\n            \"01\",\n            \"06\",\n            \"6c\",\n            \"39\",\n            \"99\",\n            \"52\",\n            \"55\",\n            \"97\",\n            \"63\",\n            \"0f\",\n            \"0a\",\n            \"64\",\n            \"90\",\n            \"bf\",\n            \"d3\",\n            \"d4\",\n            \"ba\",\n            \"a0\",\n            \"a7\",\n            \"b8\",\n            \"b1\",\n            \"dd\",\n            \"dc\",\n            \"b6\",\n            \"a9\",\n            \"d5\",\n            \"d2\",\n            \"aa\",\n            \"af\",\n            \"b7\",\n            \"db\",\n            \"a8\",\n            \"de\",\n            \"b0\",\n            \"a6\",\n            \"b9\",\n            \"a1\",\n            \"ef\",\n            \"c3\",\n            \"c4\",\n            \"ea\",\n            \"e1\",\n            \"cd\",\n            \"cc\",\n            \"e6\",\n            \"f9\",\n            \"f0\",\n            \"f7\",\n            \"e8\",\n            \"fa\",\n            \"ff\",\n            \"c5\",\n            \"c2\",\n            \"f6\",\n            \"e9\",\n            \"f1\",\n            \"e7\",\n            \"cb\",\n            \"f8\",\n            \"ce\",\n            \"e0\",\n            \"46\",\n            \"2c\",\n            \"79\",\n            \"2d\",\n            \"41\",\n            \"83\",\n            \"1b\",\n            \"77\",\n            \"48\",\n            \"70\",\n            \"1e\",\n            \"84\",\n            \"4a\",\n            \"24\",\n            \"23\",\n            \"4f\",\n            \"15\",\n            \"12\",\n            \"8c\",\n            \"85\",\n            \"1d\",\n            \"71\",\n            \"76\",\n            \"1c\",\n            \"82\",\n            \"49\",\n            \"40\",\n            \"2e\",\n            \"2b\",\n            \"47\",\n            \"78\",\n            \"8b\",\n            \"13\",\n            \"7f\",\n            \"7a\",\n            \"14\",\n            \"8e\",\n            \"22\",\n            \"25\"\n        ],\n        \"files\": {}\n    },\n    \".git/objects/61\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/0d\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/95\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/59\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/92\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/0c\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/66\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/3e\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/50\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/68\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/57\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/3b\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/6f\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/03\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/9b\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/9e\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/04\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/6a\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/32\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/35\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/69\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/3c\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/56\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/51\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/3d\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/58\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/67\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/0b\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/93\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/94\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/0e\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/60\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/34\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/5a\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/5f\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/33\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/05\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/9d\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/9c\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/02\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/a4\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/a3\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/b5\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/b2\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/d9\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/ad\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/bb\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/d7\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/d0\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/be\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/b3\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/df\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/da\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/b4\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/a2\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/a5\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/bd\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/d1\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/d6\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/bc\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/ae\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/d8\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/ab\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/e5\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/e2\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/f4\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/f3\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/eb\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/c7\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/c0\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/ee\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/c9\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/fc\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/fd\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/f2\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/f5\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/e3\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/cf\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/ca\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/e4\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/fe\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/c8\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/fb\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/ed\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/c1\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/c6\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/ec\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/4e\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/20\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/18\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/27\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/4b\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/pack\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/7d\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/29\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/7c\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/16\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/42\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/89\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/45\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/1f\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/73\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/87\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/80\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/74\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/1a\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/28\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/17\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/7b\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/8f\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/8a\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/7e\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/10\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/19\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/4c\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/26\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/21\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/4d\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/75\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/81\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/86\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/72\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/44\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/2a\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/2f\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/43\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/88\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/9f\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/6b\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/07\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/38\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/00\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/6e\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/9a\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/36\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/5c\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/09\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/5d\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/31\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/info\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/91\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/65\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/62\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/96\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/3a\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/54\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/98\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/53\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/3f\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/30\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/5e\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/5b\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/37\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/08\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/6d\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/01\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/06\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/6c\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/39\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/99\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/52\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/55\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/97\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/63\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/0f\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/0a\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/64\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/90\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/bf\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/d3\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/d4\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/ba\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/a0\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/a7\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/b8\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/b1\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/dd\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/dc\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/b6\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/a9\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/d5\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/d2\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/aa\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/af\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/b7\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/db\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/a8\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/de\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/b0\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/a6\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/b9\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/a1\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/ef\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/c3\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/c4\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/ea\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/e1\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/cd\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/cc\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/e6\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/f9\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/f0\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/f7\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/e8\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/fa\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/ff\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/c5\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/c2\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/f6\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/e9\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/f1\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/e7\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/cb\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/f8\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/ce\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/e0\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/46\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/2c\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/79\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/2d\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/41\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/83\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/1b\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/77\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/48\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/70\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/1e\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/84\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/4a\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/24\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/23\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/4f\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/15\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/12\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/8c\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/85\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/1d\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/71\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/76\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/1c\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/82\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/49\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/40\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/2e\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/2b\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/47\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/78\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/8b\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/13\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/7f\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/7a\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/14\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/8e\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/22\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/objects/25\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/info\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/logs\": {\n        \"directories\": [\n            \"refs\"\n        ],\n        \"files\": {}\n    },\n    \".git/logs/refs\": {\n        \"directories\": [\n            \"heads\",\n            \"remotes\"\n        ],\n        \"files\": {}\n    },\n    \".git/logs/refs/heads\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/logs/refs/remotes\": {\n        \"directories\": [\n            \"origin\"\n        ],\n        \"files\": {}\n    },\n    \".git/logs/refs/remotes/origin\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/hooks\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/refs\": {\n        \"directories\": [\n            \"heads\",\n            \"tags\",\n            \"remotes\"\n        ],\n        \"files\": {}\n    },\n    \".git/refs/heads\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/refs/tags\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".git/refs/remotes\": {\n        \"directories\": [\n            \"origin\"\n        ],\n        \"files\": {}\n    },\n    \".git/refs/remotes/origin\": {\n        \"directories\": [],\n        \"files\": {}\n    },\n    \".vscode\": {\n        \"directories\": [],\n        \"files\": {\n            \"settings.json\": \"{\\n    \\\"github.copilot.enable\\\": {\\n        \\\"python\\\": true\\n    }\\n}\"\n        }\n    }\n}",
            "device_list.txt": "",
            "logger.py": "import os\nfrom datetime import datetime\nfrom bot_utils import load_whitelist\n\nBOT_WHITELIST_FILE = \"bot_whitelist.txt\"\n\n# Log user requests\nasync def log_request(user_id, username, command):  # ✅ Ensure it expects three arguments\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    log_entry = f\"[{timestamp}] {username} ({user_id}) used: {command}\\n\"\n\n    with open(\"bot_requests.log\", \"a\") as log_file:\n        log_file.write(log_entry)\n\n    # Check if the user is in the whitelist\n    bot_whitelist = load_whitelist(BOT_WHITELIST_FILE)\n    if str(user_id) not in bot_whitelist:\n        print(f\"🚨 Unauthorized access attempt: {username} ({user_id}) tried {command}\")",
            "README.md": "# pi_ip_bot\n\n\ntest\n",
            "piipbot.py": "# /Users/alexanderashavskiy/projects/pi_ip_bot/piipbot.py\n\nimport os\nimport importlib\nimport logging\nfrom dotenv import load_dotenv\nfrom telegram import Update, ReplyKeyboardRemove\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandler\nfrom commands.admin import handle_approval, handle_approval_callback\nfrom commands.start import start_command\nfrom commands.menu import menu_command, handle_menu_buttons, get_main_menu\n\n# Load environment variables\nload_dotenv()\nBOT_TOKEN = os.getenv(\"BOT_TOKEN\")\nADMIN_ID = os.getenv(\"ADMIN_ID\")\n\nif not ADMIN_ID:\n    raise ValueError(\"ADMIN_ID is not set in the environment variables.\")\n\n# Function to dynamically load command handlers from the \"commands\" folder\ndef load_commands():\n    commands = {}\n    commands_dir = \"commands\"\n\n    for filename in os.listdir(commands_dir):\n        if filename.endswith(\".py\") and filename != \"__init__.py\":\n            module_name = f\"{commands_dir}.{filename[:-3]}\"  # Remove .py extension\n            module = importlib.import_module(module_name)\n\n            if hasattr(module, f\"{filename[:-3]}_command\"):\n                commands[filename[:-3]] = getattr(module, f\"{filename[:-3]}_command\")\n\n    return commands\n\n# Main function to start the bot\ndef main():\n    app = Application.builder().token(BOT_TOKEN).build()\n\n    # Dynamically load all command handlers\n    commands = load_commands()\n    for cmd_name, cmd_func in commands.items():\n        app.add_handler(CommandHandler(cmd_name, cmd_func))\n        print(f\"✅ Loaded command: /{cmd_name}\")\n\n    # Add start command and button handler\n    app.add_handler(CommandHandler(\"start\", start_command))\n    app.add_handler(CallbackQueryHandler(handle_menu_buttons, pattern='^(?!approve|deny).*$'))\n    app.add_handler(CallbackQueryHandler(handle_approval_callback, pattern='^(approve|deny):'))\n\n    # Register approval handler\n    app.add_handler(MessageHandler(filters.ALL, handle_approval))\n\n    print(\"🤖 Bot is running...\")\n    app.run_polling()\n\nasync def start(update: Update, context):\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    logging.info(f\"Checking authorization for user ID: {user_id}, Username: {username}\")\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"🚫 You are not authorized to use this bot. An approval request has been sent to the admin.\")\n        return\n\n    await update.message.reply_text(\n        \"👋 Welcome to Pi IP Bot! Use the menu to select a command.\",\n        reply_markup=ReplyKeyboardRemove()\n    )\n    await update.message.reply_text(\n        \"📍 Main Menu:\",\n        reply_markup=get_main_menu()\n    )\n\nif __name__ == \"__main__\":\n    main()",
            "bot_utils.py": "import os\nimport logging\nfrom telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup\n\nADMIN_ID = os.getenv(\"ADMIN_ID\")\n\ndef load_whitelist(filename):\n    if not os.path.exists(filename):\n        return set()\n    with open(filename, \"r\") as f:\n        return set(line.strip().split()[0] for line in f if line.strip())\n\ndef add_to_whitelist(filename, user_id, username=None):\n    with open(filename, \"a\") as f:\n        if username:\n            f.write(f\"{user_id}  # {username}\\n\")\n        else:\n            f.write(f\"{user_id}\\n\")\n\ndef is_user_in_whitelist(filename, user_id):\n    whitelist = load_whitelist(filename)\n    return str(user_id) in whitelist\n\ndef check_whitelist(user_id):\n    return is_user_in_whitelist(BOT_WHITELIST_FILE, user_id)\n\nBOT_WHITELIST_FILE = \"bot_whitelist.txt\"\nVPN_WHITELIST_FILE = \"vpn_whitelist.txt\"\n\nVPN_WHITELIST = load_whitelist(VPN_WHITELIST_FILE)\n\ndef is_user_in_bot_whitelist(user_id):\n    return is_user_in_whitelist(BOT_WHITELIST_FILE, user_id)\n\ndef is_user_in_vpn_whitelist(user_id):\n    return is_user_in_whitelist(VPN_WHITELIST_FILE, user_id)\n\ndef add_user_to_bot_whitelist(user_id, username=None):\n    add_to_whitelist(BOT_WHITELIST_FILE, user_id, username)\n\ndef add_to_vpn_whitelist(user_id, username=None):\n    add_to_whitelist(VPN_WHITELIST_FILE, user_id, username)\n\ndef is_user_authorized(user_id):\n    authorized_users = load_whitelist(BOT_WHITELIST_FILE)\n    logging.info(f\"Authorized users: {authorized_users}\")\n    return user_id in authorized_users\n\nasync def request_approval(user_id, username, approval_type):\n    bot = Bot(token=os.getenv(\"BOT_TOKEN\"))\n    admin_id = os.getenv(\"ADMIN_ID\")\n    if not admin_id:\n        raise ValueError(\"ADMIN_ID is not set in the environment variables.\")\n    message = f\"🚨 Approval request for {approval_type} access:\\nUser ID: {user_id}\\nUsername: @{username}\"\n    keyboard = [\n        [\n            InlineKeyboardButton(\"Approve\", callback_data=f\"approve:{user_id}:{username}:{approval_type}\"),\n            InlineKeyboardButton(\"Deny\", callback_data=f\"deny:{user_id}:{username}:{approval_type}\")\n        ]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    await bot.send_message(chat_id=admin_id, text=message, reply_markup=reply_markup)\n"
        }
    },
    ".pytest_cache": {
        "directories": [
            "v"
        ],
        "files": {
            "README.md": "# pytest cache directory #\n\nThis directory contains data from the pytest's cache plugin,\nwhich provides the `--lf` and `--ff` options, as well as the `cache` fixture.\n\n**Do not** commit this to version control.\n\nSee [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.\n"
        }
    },
    ".pytest_cache/v": {
        "directories": [
            "cache"
        ],
        "files": {}
    },
    ".pytest_cache/v/cache": {
        "directories": [],
        "files": {}
    },
    "tests": {
        "directories": [],
        "files": {
            "test_bot.py": "import pytest\nimport asyncio\nimport sys\nimport os\nfrom telegram import Update, User, Message, Chat, CallbackQuery\nfrom telegram.ext import CallbackContext\n\n# Добавляем корневую директорию проекта в sys.path\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nfrom bot_utils import is_user_authorized, request_approval, add_to_whitelist, BOT_WHITELIST_FILE, VPN_WHITELIST_FILE\nfrom commands.menu import menu_command, vpn_menu\nfrom commands.admin import handle_approval_callback\n\n@pytest.fixture\ndef mock_update():\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    return Update(update_id=1, message=message)\n\n@pytest.fixture\ndef mock_context(mock_update):\n    return CallbackContext.from_update(mock_update, None)\n\n@pytest.fixture\ndef mock_callback_query():\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    return CallbackQuery(id=1, from_user=user, message=message, chat_instance=\"instance\", data=\"\")\n\n@pytest.mark.asyncio\nasync def test_menu_command_authorized(mock_update, mock_context, monkeypatch):\n    def mock_is_user_authorized(user_id):\n        return True\n\n    monkeypatch.setattr('bot_utils.is_user_authorized', mock_is_user_authorized)\n    await menu_command(mock_update, mock_context)\n    assert mock_update.message.reply_text.call_count == 2\n\n@pytest.mark.asyncio\nasync def test_menu_command_unauthorized(mock_update, mock_context, monkeypatch):\n    def mock_is_user_authorized(user_id):\n        return False\n\n    async def mock_request_approval(user_id, username, approval_type):\n        pass\n\n    monkeypatch.setattr('bot_utils.is_user_authorized', mock_is_user_authorized)\n    monkeypatch.setattr('bot_utils.request_approval', mock_request_approval)\n    await menu_command(mock_update, mock_context)\n    assert mock_update.message.reply_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_vpn_menu_authorized(mock_update, mock_context, monkeypatch):\n    def mock_is_user_in_vpn_whitelist(user_id):\n        return True\n\n    monkeypatch.setattr('bot_utils.is_user_in_vpn_whitelist', mock_is_user_in_vpn_whitelist)\n    await vpn_menu(mock_update, mock_context)\n    assert mock_update.message.reply_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_vpn_menu_unauthorized(mock_update, mock_context, monkeypatch):\n    def mock_is_user_in_vpn_whitelist(user_id):\n        return False\n\n    async def mock_request_approval(user_id, username, approval_type):\n        pass\n\n    monkeypatch.setattr('bot_utils.is_user_in_vpn_whitelist', mock_is_user_in_vpn_whitelist)\n    monkeypatch.setattr('bot_utils.request_approval', mock_request_approval)\n    await vpn_menu(mock_update, mock_context)\n    assert mock_update.message.reply_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_handle_approval_callback_approve_bot(mock_context, monkeypatch):\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    callback_query = CallbackQuery(id=1, from_user=user, message=message, chat_instance=\"instance\", data=\"approve:12345:TestUser:bot\")\n    update = Update(update_id=1, callback_query=callback_query)\n\n    def mock_add_to_whitelist(filename, user_id, username):\n        assert filename == BOT_WHITELIST_FILE\n        assert user_id == \"12345\"\n        assert username == \"TestUser\"\n\n    monkeypatch.setattr('bot_utils.add_to_whitelist', mock_add_to_whitelist)\n    await handle_approval_callback(update, mock_context)\n    assert update.callback_query.edit_message_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_handle_approval_callback_approve_vpn(mock_context, monkeypatch):\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    callback_query = CallbackQuery(id=1, from_user=user, message=message, chat_instance=\"instance\", data=\"approve:12345:TestUser:vpn\")\n    update = Update(update_id=1, callback_query=callback_query)\n\n    def mock_add_to_whitelist(filename, user_id, username):\n        assert filename == VPN_WHITELIST_FILE\n        assert user_id == \"12345\"\n        assert username == \"TestUser\"\n\n    monkeypatch.setattr('bot_utils.add_to_whitelist', mock_add_to_whitelist)\n    await handle_approval_callback(update, mock_context)\n    assert update.callback_query.edit_message_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_handle_approval_callback_deny(mock_context):\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    callback_query = CallbackQuery(id=1, from_user=user, message=message, chat_instance=\"instance\", data=\"deny:12345:TestUser:bot\")\n    update = Update(update_id=1, callback_query=callback_query)\n\n    await handle_approval_callback(update, mock_context)\n    assert update.callback_query.edit_message_text.call_count == 1\n",
            "import pytest.py": "import pytest\nfrom unittest.mock import patch, MagicMock\nfrom piipbot import main, load_commands\n\n@pytest.fixture\ndef mock_env(monkeypatch):\n    monkeypatch.setenv(\"BOT_TOKEN\", \"test_token\")\n    monkeypatch.setenv(\"ADMIN_ID\", \"admin_id\")\n\n@pytest.fixture\ndef mock_application_builder():\n    with patch('piipbot.Application.builder') as mock_builder:\n        mock_app = MagicMock()\n        mock_builder.return_value.token.return_value.build.return_value = mock_app\n        yield mock_app\n\n@pytest.fixture\ndef mock_load_commands():\n    with patch('piipbot.load_commands') as mock_load:\n        mock_load.return_value = {\n            \"test_command\": MagicMock()\n        }\n        yield mock_load\n\ndef test_main(mock_env, mock_application_builder, mock_load_commands):\n    main()\n\n    # Check if the bot token is set correctly\n    mock_application_builder.builder().token.assert_called_with(\"test_token\")\n\n    # Check if the command handlers are added correctly\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n    mock_application_builder.add_handler.assert_any_call(MagicMock())\n\n    # Check if the bot is running\n    mock_application_builder.run_polling.assert_called_once()"
        }
    },
    "scripts": {
        "directories": [],
        "files": {}
    },
    "commands": {
        "directories": [
            "vpn"
        ],
        "files": {
            "start.py": "from telegram import Update, ReplyKeyboardRemove\nfrom telegram.ext import CallbackContext\nfrom commands.menu import get_main_menu\nfrom logger import log_request\n\nasync def start_command(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    await log_request(user_id, username, \"/start\")\n\n    await update.message.reply_text(\n        \"👋 Welcome to Pi IP Bot! Use the menu to select a command.\",\n        reply_markup=ReplyKeyboardRemove()\n    )\n    await update.message.reply_text(\n        \"📍 Main Menu:\",\n        reply_markup=get_main_menu()\n    )",
            "menu.py": "# /Users/alexanderashavskiy/projects/pi_ip_bot/commands/menu.py\n\nfrom telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove\nfrom telegram.ext import CallbackContext, ConversationHandler, CommandHandler, MessageHandler, filters\nfrom bot_utils import is_user_authorized, request_approval\nfrom commands.ip import ip_command\nfrom commands.uptime import uptime_command\nimport logging\n\n# Define states for the conversation\nDEVICE_NAME, REMOVE_DEVICE_NAME = range(2)\n\ndef get_main_menu():\n    return ReplyKeyboardMarkup([\n        [\"🌐 IP\", \"⏳ Uptime\"]\n    ], resize_keyboard=True, one_time_keyboard=True)\n\nasync def menu_command(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"🚫 You are not authorized to use this bot. An approval request has been sent to the admin.\")\n        return\n\n    await update.message.reply_text(\n        \"📍 Main Menu:\",\n        reply_markup=get_main_menu()  # Send the main menu only once\n    )\n\nasync def handle_menu_buttons(update: Update, context: CallbackContext) -> None:\n    if update.message:\n        text = update.message.text.strip()\n        message = update.message\n    elif update.callback_query:\n        text = update.callback_query.data\n        message = update.callback_query.message\n    else:\n        return\n\n    context.args = text.split()\n\n    if text == \"🌐 IP\":\n        await ip_command(update, context)\n    elif text == \"⏳ Uptime\":\n        await uptime_command(update, context)\n    else:\n        await message.reply_text(\"❌ Unknown command. Please use the menu or type /help for available commands.\")",
            "admin.py": "import logging\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import CallbackContext\nfrom bot_utils import add_to_whitelist, is_user_authorized, request_approval, BOT_WHITELIST_FILE, VPN_WHITELIST_FILE\n\nasync def handle_approval(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"🚫 You are not authorized to use this bot. An approval request has been sent to the admin.\")\n    else:\n        await update.message.reply_text(\"✅ You are authorized to use this bot.\")\n        add_to_whitelist(BOT_WHITELIST_FILE, user_id, username)\n\nasync def handle_approval_callback(update: Update, context: CallbackContext) -> None:\n    query = update.callback_query\n    await query.answer()\n    data = query.data.split(':')\n    action = data[0]\n    user_id = data[1]\n    username = data[2]\n    approval_type = data[3]\n\n    logging.info(f\"Approval action: {action}, User ID: {user_id}, Username: {username}, Type: {approval_type}\")\n\n    if action == 'approve':\n        if approval_type == 'bot':\n            add_to_whitelist(BOT_WHITELIST_FILE, user_id, username)\n        elif approval_type == 'vpn':\n            add_to_whitelist(VPN_WHITELIST_FILE, user_id, username)\n        await query.edit_message_text(f\"✅ User @{username} (ID: {user_id}) has been approved for {approval_type} access.\")\n    elif action == 'deny':\n        await query.edit_message_text(f\"❌ User @{username} (ID: {user_id}) has been denied for {approval_type} access.\")",
            "ip.py": "import requests\nfrom telegram import Update\nfrom telegram.ext import CallbackContext\nfrom bot_utils import is_user_authorized, request_approval\n\nasync def ip_command(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"🚫 You are not authorized to use this bot. An approval request has been sent to the admin.\")\n        return\n\n    await update.message.reply_text(\"📡 Fetching your IP address...\")\n\n    try:\n        response = requests.get(\"https://api64.ipify.org?format=json\", timeout=5)\n        response.raise_for_status()  # Raise an error for bad responses\n        ip_data = response.json()\n        public_ip = ip_data.get(\"ip\", \"Unknown\")\n\n        await update.message.reply_text(f\"🌐 Public IP address: `{public_ip}`\", parse_mode=\"Markdown\")\n    except requests.RequestException:\n        await update.message.reply_text(\"⚠️ Error: Unable to fetch public IP.\")",
            "uptime.py": "import subprocess\nfrom telegram import Update\nfrom telegram.ext import CallbackContext\nfrom bot_utils import is_user_authorized, request_approval\nfrom logger import log_request\n\nasync def uptime_command(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"🚫 You are not authorized to use this bot. An approval request has been sent to the admin.\")\n        return\n\n    await log_request(user_id, username, \"/uptime\")\n\n    try:\n        # Get system uptime\n        uptime_output = subprocess.check_output(\"uptime -p\", shell=True).decode().strip()\n        await update.message.reply_text(f\"⏳ Server Uptime: `{uptime_output}`\", parse_mode=\"Markdown\")\n\n    except subprocess.CalledProcessError as e:\n        await update.message.reply_text(\"❌ Error: Unable to fetch system uptime.\")\n        print(f\"ERROR: Failed to fetch uptime - {e}\")  # Log the error"
        }
    },
    "commands/vpn": {
        "directories": [],
        "files": {}
    },
    ".git": {
        "directories": [
            "objects",
            "info",
            "logs",
            "hooks",
            "refs"
        ],
        "files": {}
    },
    ".git/objects": {
        "directories": [
            "61",
            "0d",
            "95",
            "59",
            "92",
            "0c",
            "66",
            "3e",
            "50",
            "68",
            "57",
            "3b",
            "6f",
            "03",
            "9b",
            "9e",
            "04",
            "6a",
            "32",
            "35",
            "69",
            "3c",
            "56",
            "51",
            "3d",
            "58",
            "67",
            "0b",
            "93",
            "94",
            "0e",
            "60",
            "34",
            "5a",
            "5f",
            "33",
            "05",
            "9d",
            "9c",
            "02",
            "a4",
            "a3",
            "b5",
            "b2",
            "d9",
            "ad",
            "bb",
            "d7",
            "d0",
            "be",
            "b3",
            "df",
            "da",
            "b4",
            "a2",
            "a5",
            "bd",
            "d1",
            "d6",
            "bc",
            "ae",
            "d8",
            "ab",
            "e5",
            "e2",
            "f4",
            "f3",
            "eb",
            "c7",
            "c0",
            "ee",
            "c9",
            "fc",
            "fd",
            "f2",
            "f5",
            "e3",
            "cf",
            "ca",
            "e4",
            "fe",
            "c8",
            "fb",
            "ed",
            "c1",
            "c6",
            "ec",
            "4e",
            "20",
            "18",
            "27",
            "4b",
            "pack",
            "7d",
            "29",
            "7c",
            "16",
            "42",
            "89",
            "45",
            "1f",
            "73",
            "87",
            "80",
            "74",
            "1a",
            "28",
            "17",
            "7b",
            "8f",
            "8a",
            "7e",
            "10",
            "19",
            "4c",
            "26",
            "21",
            "4d",
            "75",
            "81",
            "86",
            "72",
            "44",
            "2a",
            "2f",
            "43",
            "88",
            "9f",
            "6b",
            "07",
            "38",
            "00",
            "6e",
            "9a",
            "36",
            "5c",
            "09",
            "5d",
            "31",
            "info",
            "91",
            "65",
            "62",
            "96",
            "3a",
            "54",
            "98",
            "53",
            "3f",
            "30",
            "5e",
            "5b",
            "37",
            "08",
            "6d",
            "01",
            "06",
            "6c",
            "39",
            "99",
            "52",
            "55",
            "97",
            "63",
            "0f",
            "0a",
            "64",
            "90",
            "bf",
            "d3",
            "d4",
            "ba",
            "a0",
            "a7",
            "b8",
            "b1",
            "dd",
            "dc",
            "b6",
            "a9",
            "d5",
            "d2",
            "aa",
            "af",
            "b7",
            "db",
            "a8",
            "de",
            "b0",
            "a6",
            "b9",
            "a1",
            "ef",
            "c3",
            "c4",
            "ea",
            "e1",
            "cd",
            "cc",
            "e6",
            "f9",
            "f0",
            "f7",
            "e8",
            "fa",
            "ff",
            "c5",
            "c2",
            "f6",
            "e9",
            "f1",
            "e7",
            "cb",
            "f8",
            "ce",
            "e0",
            "46",
            "2c",
            "79",
            "2d",
            "41",
            "83",
            "1b",
            "77",
            "48",
            "70",
            "1e",
            "84",
            "4a",
            "24",
            "23",
            "4f",
            "15",
            "12",
            "8c",
            "85",
            "1d",
            "71",
            "76",
            "1c",
            "82",
            "49",
            "40",
            "2e",
            "2b",
            "47",
            "78",
            "8b",
            "13",
            "7f",
            "7a",
            "14",
            "8e",
            "22",
            "25"
        ],
        "files": {}
    },
    ".git/objects/61": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/95": {
        "directories": [],
        "files": {}
    },
    ".git/objects/59": {
        "directories": [],
        "files": {}
    },
    ".git/objects/92": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/66": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/50": {
        "directories": [],
        "files": {}
    },
    ".git/objects/68": {
        "directories": [],
        "files": {}
    },
    ".git/objects/57": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/03": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/04": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/32": {
        "directories": [],
        "files": {}
    },
    ".git/objects/35": {
        "directories": [],
        "files": {}
    },
    ".git/objects/69": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/56": {
        "directories": [],
        "files": {}
    },
    ".git/objects/51": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/58": {
        "directories": [],
        "files": {}
    },
    ".git/objects/67": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/93": {
        "directories": [],
        "files": {}
    },
    ".git/objects/94": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/60": {
        "directories": [],
        "files": {}
    },
    ".git/objects/34": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/33": {
        "directories": [],
        "files": {}
    },
    ".git/objects/05": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/02": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ad": {
        "directories": [],
        "files": {}
    },
    ".git/objects/bb": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/be": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/df": {
        "directories": [],
        "files": {}
    },
    ".git/objects/da": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/bd": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/bc": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ae": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ab": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/eb": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ee": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fc": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fd": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/cf": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ca": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fe": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fb": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ed": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ec": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/20": {
        "directories": [],
        "files": {}
    },
    ".git/objects/18": {
        "directories": [],
        "files": {}
    },
    ".git/objects/27": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/pack": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/29": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/16": {
        "directories": [],
        "files": {}
    },
    ".git/objects/42": {
        "directories": [],
        "files": {}
    },
    ".git/objects/89": {
        "directories": [],
        "files": {}
    },
    ".git/objects/45": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/73": {
        "directories": [],
        "files": {}
    },
    ".git/objects/87": {
        "directories": [],
        "files": {}
    },
    ".git/objects/80": {
        "directories": [],
        "files": {}
    },
    ".git/objects/74": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/28": {
        "directories": [],
        "files": {}
    },
    ".git/objects/17": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/10": {
        "directories": [],
        "files": {}
    },
    ".git/objects/19": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/26": {
        "directories": [],
        "files": {}
    },
    ".git/objects/21": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/75": {
        "directories": [],
        "files": {}
    },
    ".git/objects/81": {
        "directories": [],
        "files": {}
    },
    ".git/objects/86": {
        "directories": [],
        "files": {}
    },
    ".git/objects/72": {
        "directories": [],
        "files": {}
    },
    ".git/objects/44": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/43": {
        "directories": [],
        "files": {}
    },
    ".git/objects/88": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/07": {
        "directories": [],
        "files": {}
    },
    ".git/objects/38": {
        "directories": [],
        "files": {}
    },
    ".git/objects/00": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/36": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/09": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/31": {
        "directories": [],
        "files": {}
    },
    ".git/objects/info": {
        "directories": [],
        "files": {}
    },
    ".git/objects/91": {
        "directories": [],
        "files": {}
    },
    ".git/objects/65": {
        "directories": [],
        "files": {}
    },
    ".git/objects/62": {
        "directories": [],
        "files": {}
    },
    ".git/objects/96": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/54": {
        "directories": [],
        "files": {}
    },
    ".git/objects/98": {
        "directories": [],
        "files": {}
    },
    ".git/objects/53": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/30": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/37": {
        "directories": [],
        "files": {}
    },
    ".git/objects/08": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/01": {
        "directories": [],
        "files": {}
    },
    ".git/objects/06": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/39": {
        "directories": [],
        "files": {}
    },
    ".git/objects/99": {
        "directories": [],
        "files": {}
    },
    ".git/objects/52": {
        "directories": [],
        "files": {}
    },
    ".git/objects/55": {
        "directories": [],
        "files": {}
    },
    ".git/objects/97": {
        "directories": [],
        "files": {}
    },
    ".git/objects/63": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/64": {
        "directories": [],
        "files": {}
    },
    ".git/objects/90": {
        "directories": [],
        "files": {}
    },
    ".git/objects/bf": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ba": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/dd": {
        "directories": [],
        "files": {}
    },
    ".git/objects/dc": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/aa": {
        "directories": [],
        "files": {}
    },
    ".git/objects/af": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/db": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/de": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ef": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ea": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/cd": {
        "directories": [],
        "files": {}
    },
    ".git/objects/cc": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fa": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ff": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/cb": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ce": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/46": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/79": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/41": {
        "directories": [],
        "files": {}
    },
    ".git/objects/83": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/77": {
        "directories": [],
        "files": {}
    },
    ".git/objects/48": {
        "directories": [],
        "files": {}
    },
    ".git/objects/70": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/84": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/24": {
        "directories": [],
        "files": {}
    },
    ".git/objects/23": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/15": {
        "directories": [],
        "files": {}
    },
    ".git/objects/12": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/85": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/71": {
        "directories": [],
        "files": {}
    },
    ".git/objects/76": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/82": {
        "directories": [],
        "files": {}
    },
    ".git/objects/49": {
        "directories": [],
        "files": {}
    },
    ".git/objects/40": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/47": {
        "directories": [],
        "files": {}
    },
    ".git/objects/78": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/13": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/14": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/22": {
        "directories": [],
        "files": {}
    },
    ".git/objects/25": {
        "directories": [],
        "files": {}
    },
    ".git/info": {
        "directories": [],
        "files": {}
    },
    ".git/logs": {
        "directories": [
            "refs"
        ],
        "files": {}
    },
    ".git/logs/refs": {
        "directories": [
            "heads",
            "remotes"
        ],
        "files": {}
    },
    ".git/logs/refs/heads": {
        "directories": [],
        "files": {}
    },
    ".git/logs/refs/remotes": {
        "directories": [
            "origin"
        ],
        "files": {}
    },
    ".git/logs/refs/remotes/origin": {
        "directories": [],
        "files": {}
    },
    ".git/hooks": {
        "directories": [],
        "files": {}
    },
    ".git/refs": {
        "directories": [
            "heads",
            "tags",
            "remotes"
        ],
        "files": {}
    },
    ".git/refs/heads": {
        "directories": [],
        "files": {}
    },
    ".git/refs/tags": {
        "directories": [],
        "files": {}
    },
    ".git/refs/remotes": {
        "directories": [
            "origin"
        ],
        "files": {}
    },
    ".git/refs/remotes/origin": {
        "directories": [],
        "files": {}
    },
    ".vscode": {
        "directories": [],
        "files": {
            "settings.json": "{\n    \"github.copilot.enable\": {\n        \"python\": true\n    },\n    \"python.testing.unittestArgs\": [\n        \"-v\",\n        \"-s\",\n        \"./tests\",\n        \"-p\",\n        \"*test.py\"\n    ],\n    \"python.testing.pytestEnabled\": false,\n    \"python.testing.unittestEnabled\": true\n}"
        }
    }
}
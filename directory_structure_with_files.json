{
    "": {
        "directories": [
            ".pytest_cache",
            "tests",
            "scripts",
            "commands",
            ".git",
            ".vscode"
        ],
        "files": {
            "collect_structure_and_files.py": "import os\nimport json\nfrom gitignore_parser import parse_gitignore\n\ndef collect_directory_structure_and_files(base_path='.'):\n    file_structure = {}\n    \n    # Parse .gitignore file if it exists\n    gitignore_file = os.path.join(base_path, '.gitignore')\n    if os.path.exists(gitignore_file):\n        is_ignored = parse_gitignore(gitignore_file)\n    else:\n        is_ignored = lambda path: False  # No gitignore file, don't ignore anything\n\n    # Walk through all directories and files starting from base_path\n    for root, dirs, files in os.walk(base_path):\n        # Skip files that match .gitignore\n        dirs[:] = [d for d in dirs if not is_ignored(os.path.join(root, d))]\n        files = [f for f in files if not is_ignored(os.path.join(root, f))]\n        \n        # Get the relative path\n        relative_root = os.path.relpath(root, base_path)\n        \n        if relative_root == '.':\n            relative_root = ''\n        \n        # Store the directory and file structure\n        file_structure[relative_root] = {\n            'directories': dirs,\n            'files': {}\n        }\n        \n        for file in files:\n            file_path = os.path.join(root, file)\n            \n            # Skip non-code files or files that can't be read\n            if file.endswith(('.py', '.txt', '.md', '.json', '.yml', '.yaml')):  # Add more extensions as needed\n                try:\n                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                        file_structure[relative_root]['files'][file] = f.read()\n                except Exception as e:\n                    print(f\"Could not read {file_path}: {e}\")\n    \n    return file_structure\n\ndef save_directory_structure_and_files(file_structure, output_filename=\"directory_structure_with_files.json\"):\n    # Save the directory structure and file contents to a JSON file\n    with open(output_filename, 'w', encoding='utf-8') as f:\n        json.dump(file_structure, f, ensure_ascii=False, indent=4)\n    print(f\"Directory structure and file contents saved to {output_filename}\")\n\nif __name__ == \"__main__\":\n    base_path = '.'  # Current directory\n    structure_with_files = collect_directory_structure_and_files(base_path)\n    save_directory_structure_and_files(structure_with_files)",
            "requirements.txt": "python-telegram-bot\nrequests\npython-dotenv",
            "device_list.txt": "",
            "logger.py": "import os\nfrom datetime import datetime\nfrom bot_utils import load_whitelist\n\nBOT_WHITELIST_FILE = \"bot_whitelist.txt\"\n\n# Log user requests\nasync def log_request(user_id, username, command):  # ‚úÖ Ensure it expects three arguments\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    log_entry = f\"[{timestamp}] {username} ({user_id}) used: {command}\\n\"\n\n    with open(\"bot_requests.log\", \"a\") as log_file:\n        log_file.write(log_entry)\n\n    # Check if the user is in the whitelist\n    bot_whitelist = load_whitelist(BOT_WHITELIST_FILE)\n    if str(user_id) not in bot_whitelist:\n        print(f\"üö® Unauthorized access attempt: {username} ({user_id}) tried {command}\")",
            "README.md": "# pi_ip_bot\n\n\ntest\n",
            "piipbot.py": "import os\nimport importlib\nimport logging\nfrom dotenv import load_dotenv\nfrom telegram import Update, ReplyKeyboardRemove\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandler, ConversationHandler\nfrom commands.admin import handle_approval, handle_approval_callback\nfrom commands.start import start_command\nfrom commands.menu import menu_command, handle_menu_buttons, vpn_menu, get_main_menu, get_conversation_handler\nfrom commands.vpn.devices import add_device, list_devices, get_config, remove_device\nfrom bot_utils import is_user_authorized, request_approval\n\n# Load environment variables\nload_dotenv()\nBOT_TOKEN = os.getenv(\"BOT_TOKEN\")\nADMIN_ID = os.getenv(\"ADMIN_ID\")\n\nif not ADMIN_ID:\n    raise ValueError(\"ADMIN_ID is not set in the environment variables.\")\n\n# Function to dynamically load command handlers from the \"commands\" folder\ndef load_commands():\n    commands = {}\n    commands_dir = \"commands\"\n\n    for filename in os.listdir(commands_dir):\n        if filename.endswith(\".py\") and filename != \"__init__.py\":\n            module_name = f\"{commands_dir}.{filename[:-3]}\"  # Remove .py extension\n            module = importlib.import_module(module_name)\n\n            if hasattr(module, f\"{filename[:-3]}_command\"):\n                commands[filename[:-3]] = getattr(module, f\"{filename[:-3]}_command\")\n\n    return commands\n\n# Main function to start the bot\ndef main():\n    app = Application.builder().token(BOT_TOKEN).build()\n\n    # Dynamically load all command handlers\n    commands = load_commands()\n    for cmd_name, cmd_func in commands.items():\n        app.add_handler(CommandHandler(cmd_name, cmd_func))\n        print(f\"‚úÖ Loaded command: /{cmd_name}\")\n\n    # Add start command and button handler\n    app.add_handler(CommandHandler(\"start\", start))\n    app.add_handler(get_conversation_handler())\n    app.add_handler(CallbackQueryHandler(handle_menu_buttons, pattern='^(?!approve|deny).*$'))\n    app.add_handler(CallbackQueryHandler(handle_approval_callback, pattern='^(approve|deny):'))\n    app.add_handler(CallbackQueryHandler(handle_menu_buttons, pattern='^remove_device:'))\n\n    # Register VPN commands\n    app.add_handler(CommandHandler(\"vpn\", vpn_menu))\n    app.add_handler(CommandHandler(\"add_device\", add_device))\n    app.add_handler(CommandHandler(\"list_devices\", list_devices))\n    app.add_handler(CommandHandler(\"get_config\", get_config))\n    app.add_handler(CommandHandler(\"remove_device\", remove_device))\n\n    # Register approval handler\n    app.add_handler(MessageHandler(filters.ALL, handle_approval))\n\n    print(\"ü§ñ Bot is running...\")\n    app.run_polling()\n\nasync def start(update: Update, context):\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    logging.info(f\"Checking authorization for user ID: {user_id}, Username: {username}\")\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"üö´ You are not authorized to use this bot. An approval request has been sent to the admin.\")\n        return\n\n    await update.message.reply_text(\n        \"üëã Welcome to Pi IP Bot! Use the menu to select a command.\",\n        reply_markup=ReplyKeyboardRemove()\n    )\n    await update.message.reply_text(\n        \"üìç Main Menu:\",\n        reply_markup=get_main_menu()\n    )\n\nif __name__ == \"__main__\":\n    main()",
            "bot_utils.py": "import os\nimport logging\nfrom telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup\n\nADMIN_ID = os.getenv(\"ADMIN_ID\")\n\ndef load_whitelist(filename):\n    if not os.path.exists(filename):\n        return set()\n    with open(filename, \"r\") as f:\n        return set(line.strip().split()[0] for line in f if line.strip())\n\ndef add_to_whitelist(filename, user_id, username=None):\n    with open(filename, \"a\") as f:\n        if username:\n            f.write(f\"{user_id}  # {username}\\n\")\n        else:\n            f.write(f\"{user_id}\\n\")\n\ndef is_user_in_whitelist(filename, user_id):\n    whitelist = load_whitelist(filename)\n    return str(user_id) in whitelist\n\ndef check_whitelist(user_id):\n    return is_user_in_whitelist(BOT_WHITELIST_FILE, user_id)\n\nBOT_WHITELIST_FILE = \"bot_whitelist.txt\"\nVPN_WHITELIST_FILE = \"vpn_whitelist.txt\"\n\nVPN_WHITELIST = load_whitelist(VPN_WHITELIST_FILE)\n\ndef is_user_in_bot_whitelist(user_id):\n    return is_user_in_whitelist(BOT_WHITELIST_FILE, user_id)\n\ndef is_user_in_vpn_whitelist(user_id):\n    return is_user_in_whitelist(VPN_WHITELIST_FILE, user_id)\n\ndef add_user_to_bot_whitelist(user_id, username=None):\n    add_to_whitelist(BOT_WHITELIST_FILE, user_id, username)\n\ndef add_to_vpn_whitelist(user_id, username=None):\n    add_to_whitelist(VPN_WHITELIST_FILE, user_id, username)\n\ndef is_user_authorized(user_id):\n    authorized_users = load_whitelist(BOT_WHITELIST_FILE)\n    logging.info(f\"Authorized users: {authorized_users}\")\n    return user_id in authorized_users\n\nasync def request_approval(user_id, username, approval_type):\n    bot = Bot(token=os.getenv(\"BOT_TOKEN\"))\n    admin_id = os.getenv(\"ADMIN_ID\")\n    if not admin_id:\n        raise ValueError(\"ADMIN_ID is not set in the environment variables.\")\n    message = f\"üö® Approval request for {approval_type} access:\\nUser ID: {user_id}\\nUsername: @{username}\"\n    keyboard = [\n        [\n            InlineKeyboardButton(\"Approve\", callback_data=f\"approve:{user_id}:{username}:{approval_type}\"),\n            InlineKeyboardButton(\"Deny\", callback_data=f\"deny:{user_id}:{username}:{approval_type}\")\n        ]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    await bot.send_message(chat_id=admin_id, text=message, reply_markup=reply_markup)\n"
        }
    },
    ".pytest_cache": {
        "directories": [
            "v"
        ],
        "files": {
            "README.md": "# pytest cache directory #\n\nThis directory contains data from the pytest's cache plugin,\nwhich provides the `--lf` and `--ff` options, as well as the `cache` fixture.\n\n**Do not** commit this to version control.\n\nSee [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.\n"
        }
    },
    ".pytest_cache/v": {
        "directories": [
            "cache"
        ],
        "files": {}
    },
    ".pytest_cache/v/cache": {
        "directories": [],
        "files": {}
    },
    "tests": {
        "directories": [],
        "files": {
            "test_bot.py": "import pytest\nimport asyncio\nimport sys\nimport os\nfrom telegram import Update, User, Message, Chat, CallbackQuery\nfrom telegram.ext import CallbackContext\n\n# –î–æ–±–∞–≤–ª—è–µ–º –∫–æ—Ä–Ω–µ–≤—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞ –≤ sys.path\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nfrom bot_utils import is_user_authorized, request_approval, add_to_whitelist, BOT_WHITELIST_FILE, VPN_WHITELIST_FILE\nfrom commands.menu import menu_command, vpn_menu\nfrom commands.admin import handle_approval_callback\n\n@pytest.fixture\ndef mock_update():\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    return Update(update_id=1, message=message)\n\n@pytest.fixture\ndef mock_context(mock_update):\n    return CallbackContext.from_update(mock_update, None)\n\n@pytest.fixture\ndef mock_callback_query():\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    return CallbackQuery(id=1, from_user=user, message=message, chat_instance=\"instance\", data=\"\")\n\n@pytest.mark.asyncio\nasync def test_menu_command_authorized(mock_update, mock_context, monkeypatch):\n    def mock_is_user_authorized(user_id):\n        return True\n\n    monkeypatch.setattr('bot_utils.is_user_authorized', mock_is_user_authorized)\n    await menu_command(mock_update, mock_context)\n    assert mock_update.message.reply_text.call_count == 2\n\n@pytest.mark.asyncio\nasync def test_menu_command_unauthorized(mock_update, mock_context, monkeypatch):\n    def mock_is_user_authorized(user_id):\n        return False\n\n    async def mock_request_approval(user_id, username, approval_type):\n        pass\n\n    monkeypatch.setattr('bot_utils.is_user_authorized', mock_is_user_authorized)\n    monkeypatch.setattr('bot_utils.request_approval', mock_request_approval)\n    await menu_command(mock_update, mock_context)\n    assert mock_update.message.reply_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_vpn_menu_authorized(mock_update, mock_context, monkeypatch):\n    def mock_is_user_in_vpn_whitelist(user_id):\n        return True\n\n    monkeypatch.setattr('bot_utils.is_user_in_vpn_whitelist', mock_is_user_in_vpn_whitelist)\n    await vpn_menu(mock_update, mock_context)\n    assert mock_update.message.reply_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_vpn_menu_unauthorized(mock_update, mock_context, monkeypatch):\n    def mock_is_user_in_vpn_whitelist(user_id):\n        return False\n\n    async def mock_request_approval(user_id, username, approval_type):\n        pass\n\n    monkeypatch.setattr('bot_utils.is_user_in_vpn_whitelist', mock_is_user_in_vpn_whitelist)\n    monkeypatch.setattr('bot_utils.request_approval', mock_request_approval)\n    await vpn_menu(mock_update, mock_context)\n    assert mock_update.message.reply_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_handle_approval_callback_approve_bot(mock_context, monkeypatch):\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    callback_query = CallbackQuery(id=1, from_user=user, message=message, chat_instance=\"instance\", data=\"approve:12345:TestUser:bot\")\n    update = Update(update_id=1, callback_query=callback_query)\n\n    def mock_add_to_whitelist(filename, user_id, username):\n        assert filename == BOT_WHITELIST_FILE\n        assert user_id == \"12345\"\n        assert username == \"TestUser\"\n\n    monkeypatch.setattr('bot_utils.add_to_whitelist', mock_add_to_whitelist)\n    await handle_approval_callback(update, mock_context)\n    assert update.callback_query.edit_message_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_handle_approval_callback_approve_vpn(mock_context, monkeypatch):\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    callback_query = CallbackQuery(id=1, from_user=user, message=message, chat_instance=\"instance\", data=\"approve:12345:TestUser:vpn\")\n    update = Update(update_id=1, callback_query=callback_query)\n\n    def mock_add_to_whitelist(filename, user_id, username):\n        assert filename == VPN_WHITELIST_FILE\n        assert user_id == \"12345\"\n        assert username == \"TestUser\"\n\n    monkeypatch.setattr('bot_utils.add_to_whitelist', mock_add_to_whitelist)\n    await handle_approval_callback(update, mock_context)\n    assert update.callback_query.edit_message_text.call_count == 1\n\n@pytest.mark.asyncio\nasync def test_handle_approval_callback_deny(mock_context):\n    user = User(id=12345, first_name=\"Test\", is_bot=False)\n    chat = Chat(id=67890, type=\"private\")\n    message = Message(message_id=1, date=None, chat=chat, text=\"/start\", from_user=user)\n    callback_query = CallbackQuery(id=1, from_user=user, message=message, chat_instance=\"instance\", data=\"deny:12345:TestUser:bot\")\n    update = Update(update_id=1, callback_query=callback_query)\n\n    await handle_approval_callback(update, mock_context)\n    assert update.callback_query.edit_message_text.call_count == 1\n"
        }
    },
    "scripts": {
        "directories": [],
        "files": {}
    },
    "commands": {
        "directories": [
            "vpn"
        ],
        "files": {
            "start.py": "from telegram import Update, ReplyKeyboardRemove\nfrom telegram.ext import CallbackContext\nfrom commands.menu import get_main_menu\nfrom logger import log_request\n\nasync def start_command(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    await log_request(user_id, username, \"/start\")\n\n    await update.message.reply_text(\n        \"üëã Welcome to Pi IP Bot! Use the menu to select a command.\",\n        reply_markup=ReplyKeyboardRemove()\n    )\n    await update.message.reply_text(\n        \"üìç Main Menu:\",\n        reply_markup=get_main_menu()\n    )",
            "menu.py": "from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import CallbackContext, ConversationHandler, CommandHandler, MessageHandler, filters\nfrom bot_utils import is_user_in_vpn_whitelist, is_user_authorized, request_approval\nfrom commands.vpn.devices import add_device, list_devices, get_config, remove_device\nfrom commands.ip import ip_command\nfrom commands.uptime import uptime_command\nimport logging\n\n# Define states for the conversation\nDEVICE_NAME, REMOVE_DEVICE_NAME = range(2)\n\ndef get_main_menu():\n    return ReplyKeyboardMarkup([\n        [\"üåê IP\", \"‚è≥ Uptime\"],\n        [\"üîê VPN\"]\n    ], resize_keyboard=True, one_time_keyboard=True)\n\ndef get_vpn_menu():\n    return ReplyKeyboardMarkup([\n        [\"‚ûï Add Device\", \"üìã List Devices\"],\n        [\"üîë Get Config\", \"‚ùå Remove Device\"],\n        [\"üîô Main Menu\"]\n    ], resize_keyboard=True, one_time_keyboard=True)\n\nasync def menu_command(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"üö´ You are not authorized to use this bot. An approval request has been sent to the admin.\")\n        return\n\n    await update.message.reply_text(\n        \"üìç Main Menu:\",\n        reply_markup=ReplyKeyboardRemove()\n    )\n    await update.message.reply_text(\n        \"üìç Main Menu:\",\n        reply_markup=get_main_menu()\n    )\n\nasync def vpn_menu(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    logging.info(f\"Checking VPN authorization for user ID: {user_id}, Username: {username}\")\n\n    if not is_user_in_vpn_whitelist(user_id):\n        await request_approval(user_id, username, \"vpn\")\n        await update.message.reply_text(\"‚ùå You are not authorized for VPN access. An approval request has been sent to the admin.\")\n        return\n\n    await update.message.reply_text(\"üîê VPN Menu:\", reply_markup=get_vpn_menu())\n\nasync def handle_menu_buttons(update: Update, context: CallbackContext) -> None:\n    if update.message:\n        text = update.message.text.strip()\n        message = update.message\n    elif update.callback_query:\n        text = update.callback_query.data\n        message = update.callback_query.message\n    else:\n        return\n\n    context.args = text.split()\n\n    if text == \"üåê IP\":\n        await ip_command(update, context)\n    elif text == \"‚è≥ Uptime\":\n        await uptime_command(update, context)\n    elif text == \"üîê VPN\":\n        await vpn_menu(update, context)\n    elif text == \"‚ûï Add Device\":\n        await update.message.reply_text(\"Please enter the device name:\")\n        return DEVICE_NAME\n    elif text == \"üìã List Devices\":\n        await list_devices(update, context)\n    elif text == \"üîë Get Config\":\n        await get_config(update, context)\n    elif text == \"‚ùå Remove Device\":\n        await update.message.reply_text(\"Please enter the device name to remove:\")\n        return REMOVE_DEVICE_NAME\n    elif text.startswith(\"remove_device:\"):\n        device_name = text.split(\":\")[1]\n        context.args = [device_name]\n        await remove_device(update, context)\n    elif text == \"üîô Main Menu\":\n        await menu_command(update, context)\n    else:\n        await message.reply_text(\"‚ùå Unknown command. Please use the menu or type /help for available commands.\")\n\nasync def device_name_handler(update: Update, context: CallbackContext) -> None:\n    device_name = update.message.text.strip()\n    context.args = [device_name]\n    await add_device(update, context)\n    return ConversationHandler.END\n\nasync def remove_device_name_handler(update: Update, context: CallbackContext) -> None:\n    device_name = update.message.text.strip()\n    context.args = [device_name]\n    await remove_device(update, context)\n    return ConversationHandler.END\n\nasync def cancel(update: Update, context: CallbackContext) -> None:\n    await update.message.reply_text(\"Operation cancelled.\", reply_markup=get_main_menu())\n    return ConversationHandler.END\n\ndef get_conversation_handler():\n    return ConversationHandler(\n        entry_points=[MessageHandler(filters.TEXT & ~filters.COMMAND, handle_menu_buttons)],\n        states={\n            DEVICE_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, device_name_handler)],\n            REMOVE_DEVICE_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, remove_device_name_handler)]\n        },\n        fallbacks=[CommandHandler(\"cancel\", cancel)]\n    )",
            "admin.py": "import logging\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import CallbackContext\nfrom bot_utils import add_to_whitelist, is_user_authorized, request_approval, BOT_WHITELIST_FILE, VPN_WHITELIST_FILE\n\nasync def handle_approval(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"üö´ You are not authorized to use this bot. An approval request has been sent to the admin.\")\n    else:\n        await update.message.reply_text(\"‚úÖ You are authorized to use this bot.\")\n        add_to_whitelist(BOT_WHITELIST_FILE, user_id, username)\n\nasync def handle_approval_callback(update: Update, context: CallbackContext) -> None:\n    query = update.callback_query\n    await query.answer()\n    data = query.data.split(':')\n    action = data[0]\n    user_id = data[1]\n    username = data[2]\n    approval_type = data[3]\n\n    logging.info(f\"Approval action: {action}, User ID: {user_id}, Username: {username}, Type: {approval_type}\")\n\n    if action == 'approve':\n        if approval_type == 'bot':\n            add_to_whitelist(BOT_WHITELIST_FILE, user_id, username)\n        elif approval_type == 'vpn':\n            add_to_whitelist(VPN_WHITELIST_FILE, user_id, username)\n        await query.edit_message_text(f\"‚úÖ User @{username} (ID: {user_id}) has been approved for {approval_type} access.\")\n    elif action == 'deny':\n        await query.edit_message_text(f\"‚ùå User @{username} (ID: {user_id}) has been denied for {approval_type} access.\")",
            "ip.py": "import requests\nfrom telegram import Update\nfrom telegram.ext import CallbackContext\nfrom bot_utils import is_user_authorized, request_approval\n\nasync def ip_command(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"üö´ You are not authorized to use this bot. An approval request has been sent to the admin.\")\n        return\n\n    await update.message.reply_text(\"üì° Fetching your IP address...\")\n\n    try:\n        response = requests.get(\"https://api64.ipify.org?format=json\", timeout=5)\n        response.raise_for_status()  # Raise an error for bad responses\n        ip_data = response.json()\n        public_ip = ip_data.get(\"ip\", \"Unknown\")\n\n        await update.message.reply_text(f\"üåê Your public IP address: `{public_ip}`\", parse_mode=\"Markdown\")\n    except requests.RequestException:\n        await update.message.reply_text(\"‚ö†Ô∏è Error: Unable to fetch public IP.\")",
            "uptime.py": "import subprocess\nfrom telegram import Update\nfrom telegram.ext import CallbackContext\nfrom bot_utils import is_user_authorized, request_approval\nfrom logger import log_request\n\nasync def uptime_command(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or \"Unknown\"\n\n    if not is_user_authorized(user_id):\n        await request_approval(user_id, username, \"bot\")\n        await update.message.reply_text(\"üö´ You are not authorized to use this bot. An approval request has been sent to the admin.\")\n        return\n\n    await log_request(user_id, username, \"/uptime\")\n\n    try:\n        # Get system uptime\n        uptime_output = subprocess.check_output(\"uptime -p\", shell=True).decode().strip()\n        await update.message.reply_text(f\"‚è≥ Server Uptime: `{uptime_output}`\", parse_mode=\"Markdown\")\n\n    except subprocess.CalledProcessError as e:\n        await update.message.reply_text(\"‚ùå Error: Unable to fetch system uptime.\")\n        print(f\"ERROR: Failed to fetch uptime - {e}\")  # Log the error"
        }
    },
    "commands/vpn": {
        "directories": [],
        "files": {
            "config.py": "import os\n\nWIREGUARD_DIR = \"/etc/wireguard\"\nCLIENTS_DIR = f\"{WIREGUARD_DIR}/clients\"\nWG_CONFIG_PATH = f\"{WIREGUARD_DIR}/wg0.conf\"\n\ndef generate_vpn_config(username, device_name):\n    \"\"\"Generate a WireGuard configuration file for a user.\"\"\"\n    client_private_key = os.popen(\"wg genkey\").read().strip()\n    client_public_key = os.popen(f\"echo '{client_private_key}' | wg pubkey\").read().strip()\n\n    server_public_key = open(f\"{WIREGUARD_DIR}/server_public.key\", \"r\").read().strip()\n    client_ip = f\"10.0.0.{100 + hash(username) % 100}/24\"\n\n    config_content = f\"\"\"[Interface]\nPrivateKey = {client_private_key}\nAddress = {client_ip}\nDNS = 1.1.1.1\n\n[Peer]\nPublicKey = {server_public_key}\nEndpoint = ashavskiy.keenetic.name:51820\nAllowedIPs = 0.0.0.0/0, ::/0\nPersistentKeepalive = 25\n\"\"\"\n\n    os.system(f\"sudo mkdir -p {CLIENTS_DIR}\")\n    config_path = f\"{CLIENTS_DIR}/{username}_{device_name}.conf\"\n\n    with open(config_path, \"w\") as f:\n        f.write(config_content)\n\n    os.system(f\"sudo chmod 600 {config_path}\")\n    os.system(f\"echo '\\n[Peer]\\nPublicKey = {client_public_key}\\nAllowedIPs = {client_ip}' | sudo tee -a {WG_CONFIG_PATH}\")\n    os.system(\"sudo systemctl restart wg-quick@wg0\")\n\n    return config_path",
            "request.py": "from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton\nfrom telegram.ext import CallbackContext\nfrom bot_utils import VPN_WHITELIST, add_to_vpn_whitelist\nimport os\n\nADMIN_ID = os.getenv(\"ADMIN_ID\")\n\nasync def request_vpn(update: Update, context: CallbackContext) -> None:\n    \"\"\"Handle user VPN access requests.\"\"\"\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or f\"User_{user_id}\"\n\n    if user_id in VPN_WHITELIST:\n        await update.message.reply_text(\"‚úÖ You already have VPN access.\")\n        return\n\n    keyboard = [\n        [InlineKeyboardButton(\"‚úÖ Approve\", callback_data=f\"vpn_approve_{user_id}_{username}\")],\n        [InlineKeyboardButton(\"‚ùå Deny\", callback_data=f\"vpn_deny_{user_id}\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n\n    await context.bot.send_message(chat_id=ADMIN_ID, text=f\"üö® New VPN request!\\n\\nUsername: @{username}\\nUser ID: {user_id}\", reply_markup=reply_markup)\n    await update.message.reply_text(\"üì® VPN request sent to the admin. Please wait for approval.\")",
            "__init__.py": "from .request import request_vpn\nfrom .approval import handle_vpn_approval  # ‚úÖ Ensure approval function is properly imported\nfrom .config import generate_vpn_config\nfrom .devices import add_device, list_devices, remove_device, get_config\n\n__all__ = [\n    \"request_vpn\",\n    \"handle_vpn_approval\",\n    \"generate_vpn_config\",\n    \"add_device\",\n    \"list_devices\",\n    \"remove_device\",\n    \"get_config\",\n]",
            "approval.py": "from telegram import Update\nfrom telegram.ext import CallbackContext\nfrom bot_utils import add_to_vpn_whitelist\n\nasync def handle_vpn_approval(update: Update, context: CallbackContext) -> None:\n    \"\"\"Handles admin approval or denial of VPN requests.\"\"\"\n    query = update.callback_query\n    await query.answer()\n\n    callback_data = query.data.split(\"_\")\n    action = callback_data[1]\n    user_id = callback_data[2]\n    username = callback_data[3] if action == \"approve\" else None\n\n    if action == \"approve\":\n        add_to_vpn_whitelist(user_id, username)\n        await query.edit_message_text(f\"‚úÖ User @{username} ({user_id}) has been approved for VPN access.\")\n        await context.bot.send_message(chat_id=user_id, text=\"üéâ You have been approved for VPN access! Use /adddevice to generate a configuration.\")\n    else:\n        await query.edit_message_text(f\"‚ùå User {user_id} was denied VPN access.\")",
            "devices.py": "import os\nimport subprocess\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import CallbackContext\nfrom bot_utils import VPN_WHITELIST_FILE, load_whitelist\nfrom dotenv import load_dotenv\n\n# Load environment variables\nload_dotenv()\n\nPRIVATE_KEY = os.getenv(\"PRIVATE_KEY\")\nSERVER_PUBLIC_KEY = os.getenv(\"SERVER_PUBLIC_KEY\")\nSERVER_IP = os.getenv(\"SERVER_IP\")\n\nif not SERVER_PUBLIC_KEY:\n    raise ValueError(\"SERVER_PUBLIC_KEY is not set in the .env file\")\n\ndef save_whitelist(filename, data):\n    with open(filename, \"a\") as file:\n        file.write(data + \"\\n\")\n\nDEVICE_LIST_DIR = \"device_lists\"\nVPN_CONFIG_DIR = \"/etc/wireguard/clients\"\n\ndef get_device_list_file(username):\n    return os.path.join(DEVICE_LIST_DIR, f\"devices.{username}.txt\")\n\ndef get_next_ip():\n    # Call a helper script to get the next available IP address\n    script_path = os.path.join(os.path.dirname(__file__), '..', '..', 'scripts', 'get_next_ip.sh')\n    result = subprocess.check_output([\"sudo\", script_path]).strip().decode('utf-8')\n    return result\n\ndef save_device_list(filename, username, device_name, remove=False):\n    # Ensure the directory exists\n    os.makedirs(os.path.dirname(filename), exist_ok=True)\n    if remove:\n        with open(filename, \"r\") as file:\n            lines = file.readlines()\n        with open(filename, \"w\") as file:\n            for line in lines:\n                if line.strip() != f\"{username}_{device_name}\":\n                    file.write(line)\n    else:\n        with open(filename, \"a\") as file:\n            file.write(f\"{username}_{device_name}\\n\")\n\nasync def list_devices(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or f\"User_{user_id}\"\n    user_devices = []\n    if os.path.exists(VPN_WHITELIST_FILE):\n        with open(VPN_WHITELIST_FILE, \"r\") as file:\n            for line in file:\n                if line.startswith(username):\n                    parts = line.strip().split()\n                    if len(parts) > 1:\n                        user_devices.append(parts[1])\n    if user_devices:\n        keyboard = [[InlineKeyboardButton(device, callback_data=f\"remove_device:{device}\") for device in user_devices]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await update.message.reply_text(\"üìã Your devices:\", reply_markup=reply_markup)\n    else:\n        await update.message.reply_text(\"‚ùå No devices found.\")\n\nasync def add_device(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or f\"User_{user_id}\"\n    if len(context.args) == 0:\n        await update.message.reply_text(\"‚ùå Please specify a device name.\")\n        return\n    device_name = context.args[0]\n\n    # Generate a new key pair for the device\n    private_key = subprocess.check_output([\"wg\", \"genkey\"]).strip().decode('utf-8')\n    public_key = subprocess.check_output([\"wg\", \"pubkey\"], input=private_key.encode('utf-8')).strip().decode('utf-8')\n\n    # Get the next available IP address\n    device_ip = get_next_ip()\n\n    device_config = os.path.join(VPN_CONFIG_DIR, f\"{username}_{device_name}.conf\")\n    with open(device_config, \"w\") as f:\n        f.write(f\"[Interface]\\nPrivateKey = {private_key}\\nAddress = {device_ip}/24\\n\\n[Peer]\\nPublicKey = {SERVER_PUBLIC_KEY}\\nEndpoint = {SERVER_IP}:51820\\nAllowedIPs = 0.0.0.0/0, ::/0\\n\")\n    save_whitelist(VPN_WHITELIST_FILE, f\"{username} {device_name}\")\n    \n    # Use a helper script to add device to wg0.conf and restart WireGuard\n    script_path = os.path.join(os.path.dirname(__file__), '..', '..', 'scripts', 'helper_script.sh')\n    subprocess.run([\"sudo\", script_path, \"add\", username, device_name, public_key, device_ip])\n    \n    await update.message.reply_document(open(device_config, \"rb\"), filename=f\"{username}_{device_name}.conf\")\n\nasync def remove_device(update: Update, context: CallbackContext) -> None:\n    if update.message:\n        user_id = str(update.message.from_user.id)\n        username = update.message.from_user.username or f\"User_{user_id}\"\n        reply_func = update.message.reply_text\n    elif update.callback_query:\n        user_id = str(update.callback_query.from_user.id)\n        username = update.callback_query.from_user.username or f\"User_{user_id}\"\n        reply_func = update.callback_query.message.reply_text\n    else:\n        return\n\n    if context.args is None or len(context.args) == 0:\n        await reply_func(\"‚ùå Please specify a device name to remove.\")\n        return\n    device_name = context.args[0]\n    device_config = os.path.join(VPN_CONFIG_DIR, f\"{username}_{device_name}.conf\")\n    if os.path.exists(device_config):\n        os.remove(device_config)\n        \n        # Remove device from whitelist\n        if os.path.exists(VPN_WHITELIST_FILE):\n            with open(VPN_WHITELIST_FILE, \"r\") as file:\n                lines = file.readlines()\n            with open(VPN_WHITELIST_FILE, \"w\") as file:\n                for line in lines:\n                    if line.strip() != f\"{username} {device_name}\":\n                        file.write(line)\n        \n        # Use a helper script to remove device from wg0.conf and restart WireGuard\n        script_path = os.path.join(os.path.dirname(__file__), '..', '..', 'scripts', 'helper_script.sh')\n        subprocess.run([\"sudo\", script_path, \"remove\", username, device_name])\n        await reply_func(f\"‚úÖ Device {device_name} removed and WireGuard restarted.\")\n    else:\n        await reply_func(\"‚ùå Device not found.\")\n\nasync def get_config(update: Update, context: CallbackContext) -> None:\n    user_id = str(update.message.from_user.id)\n    username = update.message.from_user.username or f\"User_{user_id}\"\n    if len(context.args) == 0:\n        await update.message.reply_text(\"‚ùå Please specify a device name.\")\n        return\n    device_name = context.args[0]\n    device_config = os.path.join(VPN_CONFIG_DIR, f\"{username}_{device_name}.conf\")\n    if os.path.exists(device_config):\n        await update.message.reply_document(open(device_config, \"rb\"), filename=f\"{username}_{device_name}.conf\")\n    else:\n        await update.message.reply_text(\"‚ùå Configuration file not found.\")\n"
        }
    },
    ".git": {
        "directories": [
            "objects",
            "info",
            "logs",
            "hooks",
            "refs"
        ],
        "files": {}
    },
    ".git/objects": {
        "directories": [
            "61",
            "0d",
            "95",
            "59",
            "92",
            "0c",
            "66",
            "3e",
            "50",
            "68",
            "57",
            "3b",
            "6f",
            "03",
            "9b",
            "9e",
            "04",
            "6a",
            "32",
            "35",
            "69",
            "3c",
            "56",
            "51",
            "3d",
            "58",
            "67",
            "0b",
            "93",
            "94",
            "0e",
            "60",
            "34",
            "5a",
            "5f",
            "33",
            "05",
            "9d",
            "9c",
            "02",
            "a4",
            "a3",
            "b5",
            "b2",
            "d9",
            "ad",
            "bb",
            "d7",
            "d0",
            "be",
            "b3",
            "df",
            "da",
            "b4",
            "a2",
            "a5",
            "bd",
            "d1",
            "d6",
            "bc",
            "ae",
            "d8",
            "ab",
            "e5",
            "e2",
            "f4",
            "f3",
            "eb",
            "c7",
            "c0",
            "ee",
            "c9",
            "fc",
            "fd",
            "f2",
            "f5",
            "e3",
            "cf",
            "ca",
            "e4",
            "fe",
            "c8",
            "fb",
            "ed",
            "c1",
            "c6",
            "ec",
            "4e",
            "20",
            "18",
            "27",
            "4b",
            "pack",
            "7d",
            "29",
            "7c",
            "16",
            "42",
            "89",
            "45",
            "1f",
            "73",
            "87",
            "80",
            "74",
            "1a",
            "28",
            "17",
            "7b",
            "8f",
            "8a",
            "7e",
            "10",
            "19",
            "4c",
            "26",
            "21",
            "4d",
            "75",
            "81",
            "86",
            "72",
            "44",
            "2a",
            "2f",
            "43",
            "88",
            "9f",
            "6b",
            "07",
            "38",
            "00",
            "6e",
            "9a",
            "36",
            "5c",
            "09",
            "5d",
            "31",
            "info",
            "91",
            "65",
            "62",
            "96",
            "3a",
            "54",
            "98",
            "53",
            "3f",
            "30",
            "5e",
            "5b",
            "37",
            "08",
            "6d",
            "01",
            "06",
            "6c",
            "39",
            "99",
            "52",
            "55",
            "97",
            "63",
            "0f",
            "0a",
            "64",
            "90",
            "bf",
            "d3",
            "d4",
            "ba",
            "a0",
            "a7",
            "b8",
            "b1",
            "dd",
            "dc",
            "b6",
            "a9",
            "d5",
            "d2",
            "aa",
            "af",
            "b7",
            "db",
            "a8",
            "de",
            "b0",
            "a6",
            "b9",
            "a1",
            "ef",
            "c3",
            "c4",
            "ea",
            "e1",
            "cd",
            "cc",
            "e6",
            "f9",
            "f0",
            "f7",
            "e8",
            "fa",
            "ff",
            "c5",
            "c2",
            "f6",
            "e9",
            "f1",
            "e7",
            "cb",
            "f8",
            "ce",
            "e0",
            "46",
            "2c",
            "79",
            "2d",
            "41",
            "83",
            "1b",
            "77",
            "48",
            "70",
            "1e",
            "84",
            "4a",
            "24",
            "23",
            "4f",
            "15",
            "12",
            "8c",
            "85",
            "1d",
            "71",
            "76",
            "1c",
            "82",
            "49",
            "40",
            "2e",
            "2b",
            "47",
            "78",
            "8b",
            "13",
            "7f",
            "7a",
            "14",
            "8e",
            "22",
            "25"
        ],
        "files": {}
    },
    ".git/objects/61": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/95": {
        "directories": [],
        "files": {}
    },
    ".git/objects/59": {
        "directories": [],
        "files": {}
    },
    ".git/objects/92": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/66": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/50": {
        "directories": [],
        "files": {}
    },
    ".git/objects/68": {
        "directories": [],
        "files": {}
    },
    ".git/objects/57": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/03": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/04": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/32": {
        "directories": [],
        "files": {}
    },
    ".git/objects/35": {
        "directories": [],
        "files": {}
    },
    ".git/objects/69": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/56": {
        "directories": [],
        "files": {}
    },
    ".git/objects/51": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/58": {
        "directories": [],
        "files": {}
    },
    ".git/objects/67": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/93": {
        "directories": [],
        "files": {}
    },
    ".git/objects/94": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/60": {
        "directories": [],
        "files": {}
    },
    ".git/objects/34": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/33": {
        "directories": [],
        "files": {}
    },
    ".git/objects/05": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/02": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ad": {
        "directories": [],
        "files": {}
    },
    ".git/objects/bb": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/be": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/df": {
        "directories": [],
        "files": {}
    },
    ".git/objects/da": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/bd": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/bc": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ae": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ab": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/eb": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ee": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fc": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fd": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/cf": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ca": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fe": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fb": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ed": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ec": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/20": {
        "directories": [],
        "files": {}
    },
    ".git/objects/18": {
        "directories": [],
        "files": {}
    },
    ".git/objects/27": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/pack": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/29": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/16": {
        "directories": [],
        "files": {}
    },
    ".git/objects/42": {
        "directories": [],
        "files": {}
    },
    ".git/objects/89": {
        "directories": [],
        "files": {}
    },
    ".git/objects/45": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/73": {
        "directories": [],
        "files": {}
    },
    ".git/objects/87": {
        "directories": [],
        "files": {}
    },
    ".git/objects/80": {
        "directories": [],
        "files": {}
    },
    ".git/objects/74": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/28": {
        "directories": [],
        "files": {}
    },
    ".git/objects/17": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/10": {
        "directories": [],
        "files": {}
    },
    ".git/objects/19": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/26": {
        "directories": [],
        "files": {}
    },
    ".git/objects/21": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/75": {
        "directories": [],
        "files": {}
    },
    ".git/objects/81": {
        "directories": [],
        "files": {}
    },
    ".git/objects/86": {
        "directories": [],
        "files": {}
    },
    ".git/objects/72": {
        "directories": [],
        "files": {}
    },
    ".git/objects/44": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/43": {
        "directories": [],
        "files": {}
    },
    ".git/objects/88": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/07": {
        "directories": [],
        "files": {}
    },
    ".git/objects/38": {
        "directories": [],
        "files": {}
    },
    ".git/objects/00": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/9a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/36": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/09": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/31": {
        "directories": [],
        "files": {}
    },
    ".git/objects/info": {
        "directories": [],
        "files": {}
    },
    ".git/objects/91": {
        "directories": [],
        "files": {}
    },
    ".git/objects/65": {
        "directories": [],
        "files": {}
    },
    ".git/objects/62": {
        "directories": [],
        "files": {}
    },
    ".git/objects/96": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/54": {
        "directories": [],
        "files": {}
    },
    ".git/objects/98": {
        "directories": [],
        "files": {}
    },
    ".git/objects/53": {
        "directories": [],
        "files": {}
    },
    ".git/objects/3f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/30": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/5b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/37": {
        "directories": [],
        "files": {}
    },
    ".git/objects/08": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/01": {
        "directories": [],
        "files": {}
    },
    ".git/objects/06": {
        "directories": [],
        "files": {}
    },
    ".git/objects/6c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/39": {
        "directories": [],
        "files": {}
    },
    ".git/objects/99": {
        "directories": [],
        "files": {}
    },
    ".git/objects/52": {
        "directories": [],
        "files": {}
    },
    ".git/objects/55": {
        "directories": [],
        "files": {}
    },
    ".git/objects/97": {
        "directories": [],
        "files": {}
    },
    ".git/objects/63": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/0a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/64": {
        "directories": [],
        "files": {}
    },
    ".git/objects/90": {
        "directories": [],
        "files": {}
    },
    ".git/objects/bf": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ba": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/dd": {
        "directories": [],
        "files": {}
    },
    ".git/objects/dc": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/d2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/aa": {
        "directories": [],
        "files": {}
    },
    ".git/objects/af": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/db": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/de": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/b9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/a1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ef": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c3": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c4": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ea": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/cd": {
        "directories": [],
        "files": {}
    },
    ".git/objects/cc": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/fa": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ff": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c5": {
        "directories": [],
        "files": {}
    },
    ".git/objects/c2": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f6": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e9": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f1": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e7": {
        "directories": [],
        "files": {}
    },
    ".git/objects/cb": {
        "directories": [],
        "files": {}
    },
    ".git/objects/f8": {
        "directories": [],
        "files": {}
    },
    ".git/objects/ce": {
        "directories": [],
        "files": {}
    },
    ".git/objects/e0": {
        "directories": [],
        "files": {}
    },
    ".git/objects/46": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/79": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/41": {
        "directories": [],
        "files": {}
    },
    ".git/objects/83": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/77": {
        "directories": [],
        "files": {}
    },
    ".git/objects/48": {
        "directories": [],
        "files": {}
    },
    ".git/objects/70": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/84": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/24": {
        "directories": [],
        "files": {}
    },
    ".git/objects/23": {
        "directories": [],
        "files": {}
    },
    ".git/objects/4f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/15": {
        "directories": [],
        "files": {}
    },
    ".git/objects/12": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/85": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1d": {
        "directories": [],
        "files": {}
    },
    ".git/objects/71": {
        "directories": [],
        "files": {}
    },
    ".git/objects/76": {
        "directories": [],
        "files": {}
    },
    ".git/objects/1c": {
        "directories": [],
        "files": {}
    },
    ".git/objects/82": {
        "directories": [],
        "files": {}
    },
    ".git/objects/49": {
        "directories": [],
        "files": {}
    },
    ".git/objects/40": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/2b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/47": {
        "directories": [],
        "files": {}
    },
    ".git/objects/78": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8b": {
        "directories": [],
        "files": {}
    },
    ".git/objects/13": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7f": {
        "directories": [],
        "files": {}
    },
    ".git/objects/7a": {
        "directories": [],
        "files": {}
    },
    ".git/objects/14": {
        "directories": [],
        "files": {}
    },
    ".git/objects/8e": {
        "directories": [],
        "files": {}
    },
    ".git/objects/22": {
        "directories": [],
        "files": {}
    },
    ".git/objects/25": {
        "directories": [],
        "files": {}
    },
    ".git/info": {
        "directories": [],
        "files": {}
    },
    ".git/logs": {
        "directories": [
            "refs"
        ],
        "files": {}
    },
    ".git/logs/refs": {
        "directories": [
            "heads",
            "remotes"
        ],
        "files": {}
    },
    ".git/logs/refs/heads": {
        "directories": [],
        "files": {}
    },
    ".git/logs/refs/remotes": {
        "directories": [
            "origin"
        ],
        "files": {}
    },
    ".git/logs/refs/remotes/origin": {
        "directories": [],
        "files": {}
    },
    ".git/hooks": {
        "directories": [],
        "files": {}
    },
    ".git/refs": {
        "directories": [
            "heads",
            "tags",
            "remotes"
        ],
        "files": {}
    },
    ".git/refs/heads": {
        "directories": [],
        "files": {}
    },
    ".git/refs/tags": {
        "directories": [],
        "files": {}
    },
    ".git/refs/remotes": {
        "directories": [
            "origin"
        ],
        "files": {}
    },
    ".git/refs/remotes/origin": {
        "directories": [],
        "files": {}
    },
    ".vscode": {
        "directories": [],
        "files": {
            "settings.json": "{\n    \"github.copilot.enable\": {\n        \"python\": true\n    }\n}"
        }
    }
}